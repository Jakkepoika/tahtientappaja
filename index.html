<!DOCTYPE html>
<html>
<head>
    <title>Tahtien Tappaja</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
	<meta http-equiv="ScreenOrientation" content="autoRotate:disabled">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        body {
			margin: 0;
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			background: black;
			font-family: Arial, sans-serif;
			position: fixed; /* Prevent scrolling */
			overflow: hidden; /* Prevent scrolling */
			width: 100%; /* Ensure full width */
			touch-action: none; /* Disable browser touch actions */
		}
        #gameCanvas {
            border: 2px solid #333;
			touch-action: none;
			will-change: transform;
			transform: translateZ(0);
			-webkit-transform: translateZ(0);
			backface-visibility: hidden;
			-webkit-backface-visibility: hidden;
        }
        .screen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(16, 22, 78, 0.4);
			color: white;
			text-align: center;
			z-index: 100;
			display: none;
			box-sizing: border-box;
			flex-direction: column;
			justify-content: space-evenly;
			align-items: center;
			/* Force exact screen dimensions */
			height: 100vh;
			height: 100dvh;
			/* Minimal padding to ensure everything fits */
			padding: 5px;
			/* Prevent any overflow */
			overflow: hidden;
		}
	
	/* Add responsive sizing classes */
	.responsive-container {
		width: 100%;
		max-width: min(400px, 95vw);
		height: 100%;
		margin: 0 auto;
		display: flex;
		flex-direction: column;
		justify-content: space-evenly;
		align-items: center;
		gap: 0;
		padding: 0;
		box-sizing: border-box;
		/* Force container to use full available height */
		flex: 1;
	}
	
	.screen img, .screen canvas {
	    max-width: 100%;
	    height: auto;
	    object-fit: contain;
	}
	
	/* Add specific spacing for elements */
	.logo-img {
		max-width: 90%;
		height: auto;
		/* Use fraction of available height instead of vh */
		max-height: 15%;
		object-fit: contain;
		flex-shrink: 0;
	}

	.character-anim {
		max-width: 80%;
		height: auto;
		/* Use fraction of available height */
		max-height: 35%;
		object-fit: contain;
		flex-shrink: 0;
	}

	.button-container {
		width: 100%;
		max-width: 335px;
		flex-shrink: 0;
	}

	#socialLinks, #socialLinks2 {
		width: 100%;
		display: flex;
		justify-content: center;
		gap: 20px;
		margin: 0;
		padding: 0;
		flex-shrink: 0;
	}
	
	/* Social link icons */
	.socialLink {
	    transition: transform 0.2s;
	    display: block;
	}
	
	.socialLink:hover, .socialLink:active {
	    transform: scale(1.1);
	}
	
	.socialLink img {
	    width: 50px;
	    height: 50px;
	    border-radius: 8px;
	    object-fit: contain;
	}
	
	/* Better support for small screens */
	@media screen and (max-height: 600px) {
		.logo-img {
			max-height: 12vh;
			margin-bottom: 2px;
		}
		.character-anim {
			max-height: 20vh;
			margin-bottom: 2px;
		}
		.button-container {
			margin: 5px auto;
		}
		.socialLink img {
			width: 35px;
			height: 35px;
		}
		#socialLinks, #socialLinks2 {
			gap: 15px;
			margin-top: 10px;
		}
	}

	/* Extra small screens */
	@media screen and (max-height: 500px) {
		.logo-img {
			max-height: 10vh;
		}
		.character-anim {
			max-height: 15vh;
		}
		.responsive-container {
			gap: 5px;
		}
		#startButtonCanvas, #restartButtonCanvas {
			height: 80px !important;
		}
	}
		#logoContainer {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			width: 100%;
		}

		#startScreen {
			z-index: 90; // Lower than loading screen
		}

		#loadingScreen {
			z-index: 95; // Higher than start screen
		}
        .button {
            background: #4CAF50;
            border: none;
            padding: 15px 30px;
            color: white;
            cursor: pointer;
            font-size: 18px;
        }
        #gameStats {
			position: fixed;
			top: 10px;
			left: 10px;
			color: white;
			z-index: 100;
			display: none;
			width: 100%;
			text-align: center;
			padding: 5px;
		}
        #gameOverScreen {
            display: none;
            z-index: 200;
        }
		.socialLink {
		    transition: transform 0.2s;
		    display: block;
		    position: relative; /* Add this */
		    z-index: 110; /* Add this to ensure icons are visible */
		}
		.socialLink:hover {
		    transform: scale(1.1);
		}
		.socialLink img {
		    border-radius: 8px;
		    width: 50px;  /* Ensure consistent width */
		    height: 50px; /* Ensure consistent height */
		    object-fit: contain; /* Maintain aspect ratio */
		}
		
		/* Add these new rules for container positioning */
		#socialLinks, #socialLinks2 {
		    margin-top: 20px;
		    display: flex;
		    justify-content: center;
		    gap: 20px;
		    width: 100%;
		    position: relative;
		    z-index: 110;
		}
		
		/* Add responsive sizing for very small screens */
		@media screen and (max-width: 360px) {
		    .socialLink img {
		        width: 40px;
		        height: 40px;
		    }
		    #socialLinks, #socialLinks2 {
		        gap: 15px;
		    }
		}
		
		/* Force no scroll for all mobile browsers */
		html, body {
		    position: fixed;
		    width: 100%;
		    height: 100%;
		    overflow: hidden;
		    -webkit-overflow-scrolling: none;
		    overscroll-behavior: none;
		    touch-action: none;
		}

		/* Prevent address bar hiding in mobile browsers */
		body {
			min-height: 100vh;
			min-height: 100dvh;
			max-height: 100vh;
			max-height: 100dvh;
			/* Force viewport height to be stable */
			height: 100vh !important;
			height: 100dvh !important;
		}

		/* Force stable viewport for game canvas */
		#gameCanvas {
			position: fixed !important;
			top: 0 !important;
			left: 50% !important;
			transform: translateX(-50%) !important;
			z-index: 1 !important;
		}

		/* Additional mobile browser fixes */
		* {
		    -webkit-touch-callout: none;
		    -webkit-user-select: none;
		    -khtml-user-select: none;
		    -moz-user-select: none;
		    -ms-user-select: none;
		    user-select: none;
		    -webkit-tap-highlight-color: transparent;
		}
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
	<div id="gameStats" style="display:none; visibility:hidden; opacity:0; position:absolute; left:-9999px;">
		<div>Score: <span id="score">0</span></div>
		<div>HP: <span id="hp">100</span></div>
	</div>

	<div id="startScreen" class="screen">
	    <div class="responsive-container">
	        <img src="LOGO.png" alt="Logo" class="logo-img">
	        <canvas id="characterAnimCanvas" width="250" height="250" class="character-anim"></canvas>
	        
	        <div class="button-container">
				<canvas id="startButtonCanvas" width="335" height="125" style="cursor: pointer; max-width: 100%;"></canvas>
			</div>
	        
	        <div id="socialLinks">
	            <a href="https://open.spotify.com/track/38Axyw968uHdx7JJxUni6y" target="_blank" class="socialLink">
	                <img src="Spoti.png" alt="Spotify">
	            </a>
	            <a href="https://www.instagram.com/jakkepoikanen?igsh=Y2d2YzBvemJqam52" target="_blank" class="socialLink">
	                <img src="ig.png" alt="Instagram">
	            </a>
	        </div>
	    </div>
	</div>

	<div id="gameOverScreen" class="screen" style="display:none;">
	    <div class="responsive-container">
	        <h2>Game Over</h2>
	        <p>Final Score: <span id="finalScore">0</span></p>
	        
	        <div class="button-container">
	            <canvas id="restartButtonCanvas" width="335" height="125" style="cursor: pointer; max-width: 100%;"></canvas>
	        </div>
	        
	        <div id="socialLinks2">
	            <a href="https://open.spotify.com/track/38Axyw968uHdx7JJxUni6y" target="_blank" class="socialLink">
	                <img src="Spoti.png" alt="Spotify">
	            </a>
	            <a href="https://www.instagram.com/jakkepoikanen?igsh=Y2d2YzBvemJqam52" target="_blank" class="socialLink">
	                <img src="ig.png" alt="Instagram">
	            </a>
	        </div>
	    </div>
	</div>
    <script>
// Screen orientation locking function
function lockScreenOrientation() {
    try {
        // For most modern browsers
        if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('portrait')
                .then(() => {
                    console.log('Screen orientation locked to portrait');
                })
                .catch(error => {
                    console.error('Screen orientation lock error:', error);
                });
        } 
        // For older iOS
        else if (window.orientation !== undefined) {
            // Can't actually lock, but can detect changes
            window.addEventListener('orientationchange', function() {
                console.log('Orientation changed to: ', window.orientation);
                // Force portrait layout regardless of physical orientation
                resizeCanvas();
            });
        }
    } catch (error) {
        console.error('Error setting up orientation lock:', error);
    }
}
// Asset loading handler
// Modify your assetLoaded function to handle the transition better
function assetLoaded() {
    try {
        assetsLoaded++;
        console.log("Asset loaded. Total: " + assetsLoaded + "/" + totalAssets);
        
        // If all assets are loaded, switch to start screen
        if (assetsLoaded >= totalAssets) {
            console.log("All assets loaded, switching to start screen");
            
            // Make sure we stop the loading animation
            if (loadingLoop) {
                cancelAnimationFrame(loadingLoop);
                loadingLoop = null;
            }
            
            // Final clear of the canvas to remove loading screen
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            setTimeout(() => {
                switchScreen("start");
            }, 500);
        }
    } catch (error) {
        console.error("Error in assetLoaded:", error);
        // Force proceed if there's an error
        if (assetsLoaded < totalAssets) {
            assetsLoaded = totalAssets;
            switchScreen("start");
        }
    }
}
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
		const startScreen = document.getElementById('startScreen');
		const gameOverScreen = document.getElementById('gameOverScreen');
		const gameStats = document.getElementById('gameStats');
		const startButton = document.getElementById('startButton');
		const restartButton = document.getElementById('restartButton');
		const scoreElement = document.getElementById('score');
		const hpElement = document.getElementById('hp');
		const finalScoreElement = document.getElementById('finalScore');
		





		
		canvas.width = 400;
        canvas.height = 800;
		
		function resizeCanvas() {
			// Get the dimensions of the viewport
			const viewportWidth = window.innerWidth;
			const viewportHeight = window.innerHeight;
			
			// Set canvas size to fit screen while maintaining aspect ratio
			if (viewportWidth / viewportHeight > 1) {
				// Landscape orientation
				canvas.height = Math.min(viewportHeight * 0.95, 800);
				canvas.width = canvas.height / 2; // Maintain your 1:2 aspect ratio
			} else {
				// Portrait orientation (most phones)
				canvas.width = Math.min(viewportWidth * 0.95, 400);
				canvas.height = canvas.width * 2; // Maintain your 1:2 aspect ratio
			}
			
			// Recreate mobile controls with new canvas dimensions
			if (isMobile) {
				createMobileControls();
			}
		}
		
        // Game state global variables
		let lastPerformanceBoost = 0;
		const PERFORMANCE_BOOST_INTERVAL = 200; // milliseconds
		let currentScreen = "loading";
		let loadingLoop;
		let totalAssets = 13; // Increased by 1 to include the missile 
		let keys = {}; // Track pressed keys
		let isMobile = false; // Will be set based on device detection
		let joystick = {
			active: false,
			baseX: 0,
			baseY: 0,
			knobX: 0,
			knobY: 0,
			radius: 50,  // Size of the joystick base
			knobRadius: 25, // Size of the inner knob
			maxDistance: 50 // Maximum distance the knob can move from center
		};

		let fireButton = {
			x: 0,
			y: 0,
			radius: 40,
			pressed: false
		};
		let gameStartSequence = false;
		let playerReady = false;
		let enemySpawningActive = false;
		let playerInvulnerable = false;
		let playerInvulnerableTimer = 0;
		let bossCollisionInvulnerability = false;
		let assetsLoaded = 0;
		let isLoading = true;
		let backgroundMusic = null;
		let isBackgroundMusicPlaying = false;
		// Main screen stars
		const mainScreenStars = [];
		// Debug mode flag - set to true to enable console logs and visual debug info
		const DEBUG_MODE = true;
		// Powerup milestone tracking
		// let reachedMilestones = [false, false, false, false];
		// Global mouse position tracking
		let mouseX, mouseY;
		const NUM_MAIN_SCREEN_STARS = 50;
		let mainScreenStarsAnimationId = null;
		let mainCharacterAnimFrame = 0;
		let mainCharacterAnimTimer = 0;
		const mainCharacterFrameCount = 4; // Your animation has 4 frames
		const mainCharacterFrameWidth = 250; // Width of each frame in pixels
		const mainCharacterFrameHeight = 1000; // Height of each frame in pixels
		const mainCharacterFrameDuration = 150; // Milliseconds per frame (adjust for speed)
		// Player animation variables
		let playerAnimFrame = 0;
		let playerAnimTimer = 0;
		// Start button animation variables
		let startButtonImage = new Image();
		// let startButtonAnimating = false;
		let startButtonFrame = 0;
		let startButtonFrameCount = 2; // Your animation has 2 frames
		let startButtonFrameWidth = 670; // Width of each frame
		let startButtonFrameHeight = 248; // Height of each frame
		// let startButtonTimer = 0;
		// let startButtonAnimationDuration = 1000; // 1 seconds for the whole animation
		// Restart button animation variables (uses same image as start button)
		// let restartButtonAnimating = false;
		let restartButtonFrame = 0;
		// let restartButtonTimer = 0;
		const playerFrameCount = 2; // Your animation has 2 frames
		const playerFrameWidth = 500; // Width of each frame in your vertical sprite sheet
		const playerFrameHeight = 500; // Height of each frame (1000px รท 2 frames = 500px per frame)
		const playerFrameDuration = 200; // Milliseconds per frame (adjust for speed)
		// Explosion animation variables
		let explosionImage = new Image();
		let explosions = []; // Array to track multiple explosions
		const explosionFrameCount = 7; // Your animation has 7 frames
		const explosionFrameWidth = 250; // Width of each frame
		const explosionFrameHeight = 172; // Height of each frame
		const explosionDuration = 250; // 0.25 seconds for the whole animation
		// Ohjus (missile) animation variables
		let ohjusImage = new Image();
		const ohjusFrameCount = 2; // Two frames for animation
		const ohjusFrameWidth = 500; // Width of each frame
		const ohjusFrameHeight = 500; // Height of each frame
		const ohjusFrameDuration = 200; // Milliseconds per frame
		// Powerup variables
		let powerup = null;
		let powerupSpawned = false;

		// Rapid Fire powerup
		let rapidFireActive = false;
		let rapidFireBulletsLeft = 0;

		// Dual Fire powerup
		let dualFireActive = false;

		// Shield powerup
		let shieldActive = false;
		let shieldHealth = 0;

		// Powerup spawn rates (percentage chance when defeating an enemy)
		const POWERUP_SPAWN_RATE = 0.05; // 5% chance to spawn any powerup
		const POWERUP_TYPES = {
			RAPID_FIRE: {id: 0, chance: 0.35, color: '#FFD700'}, // 25% of powerups (down from 60%)
			SHIELD: {id: 1, chance: 0.50, color: '#00BFFF'},     // 30% of powerups (unchanged)
			DUAL_FIRE: {id: 2, chance: 0.15, color: '#FF00FF'}   // 15% of powerups (up from 10%)
		};
        let gameLoop;
        let isGameRunning = false;
        let lastShot = 0;
        let score = 0;
        const shootingDelay = 250;
		let rapidFireShootingDelay = shootingDelay / 3; //200% faster
		let gameTime = 0; // Time in seconds
		let lastTimeCheck = 0;
		let explosionAnimation = null;
		let bossSpawned = false;
		let regularEnemiesDisabled = false;
		let boss = null;
		let bossAnimationFrame = 0;
		let bossAnimationTimer = 0;
		const bossFrameCount = 6; // Your Piskel has 6 frames
		const bossFrameWidth = 250; // Width of each frame in pixels
		const bossFrameHeight = 250; // Height of each frame in pixels
		const bossFrameDuration = 100; // Milliseconds per frame (adjust for speed)
		let lastBossMissile = 0;
		const bossMissileDelay = 5000; // 10 seconds
		window.pendingScreenTimeouts = [];
// Add this function to properly initialize loading
function startLoading() {
    console.log("Initializing loading process");
    // Switch to loading screen explicitly
    currentScreen = "loading";
    isLoading = true;
    isGameRunning = false;
    
    // Hide all UI screens during loading
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';
    document.getElementById('gameStats').style.display = 'none';
    
    // Reset asset loading counter
    assetsLoaded = 0;
    
    // Start loading animation
    console.log("Starting loading animation");
    function loadingAnimation() {
        if (currentScreen === "loading") {
            showLoadingScreen();
            loadingLoop = requestAnimationFrame(loadingAnimation);
        }
    }
    loadingLoop = requestAnimationFrame(loadingAnimation);
    
    // Start loading assets
    console.log("Starting asset loading");
    loadAllAssets();
}
function switchScreen(newScreen) {
    console.log(`Switching from ${currentScreen} to ${newScreen}`);
	// Cancel star animation if switching away from start screen
    if (currentScreen === "start" && newScreen !== "start" && mainScreenStarsAnimationId) {
        cancelAnimationFrame(mainScreenStarsAnimationId);
        mainScreenStarsAnimationId = null;
    }
    
    // Cancel any loading animation
    if (loadingLoop) {
        cancelAnimationFrame(loadingLoop);
        loadingLoop = null;
    }
    
    // Hide all screens
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const gameStats = document.getElementById('gameStats');
    
    if (startScreen) startScreen.style.display = 'none';
    if (gameOverScreen) gameOverScreen.style.display = 'none';
    if (gameStats) gameStats.style.display = 'none';
    
    // Show appropriate screen
    if (newScreen === "loading") {
        isLoading = true;
        isGameRunning = false;
        
        // Start loading animation
        loadingLoop = requestAnimationFrame(function loadingAnimation() {
            showLoadingScreen();
            loadingLoop = requestAnimationFrame(loadingAnimation);
        });
    } 
    else if (newScreen === "start") {
	    isLoading = false;
	    isGameRunning = false;
	    
	    // Draw background with stars first
	    ctx.fillStyle = '#10164e';
	    ctx.fillRect(0, 0, canvas.width, canvas.height);
	    
	    // Initialize stars before showing the UI
	    initializeMainScreenStars();
	    mainScreenStarsAnimationId = requestAnimationFrame(updateAndDrawMainScreenStars);
	    
	    // Then show the UI
	    if (startScreen) {
	        startScreen.style.display = 'flex'; // Changed from 'block' to 'flex'
	    }
	    
	    // Start main character animation
	    mainCharacterAnimFrame = 0;
	    mainCharacterAnimTimer = Date.now();
	    requestAnimationFrame(animateMainCharacter);
	    // Initialize start button
	    startButtonFrame = 0;
	    updateStartButton();
	}
    else if (newScreen === "game") {
        isLoading = false;
        isGameRunning = true;
        
        if (gameStats) {
            gameStats.style.display = 'block';
        }
    } 
    else if (newScreen === "gameOver") {
	    isLoading = false;
	    isGameRunning = false;
	    
	    if (gameOverScreen) {
	        gameOverScreen.style.display = 'flex'; // Changed from 'block' to 'flex'
	        // Initialize restart button
	        restartButtonFrame = 0;
	        updateRestartButton();
	    }
	}
    
    currentScreen = newScreen;
}
function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
function detectMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
           (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);
}
function createMobileControls() {
    // No longer needed with new touch control system
    // Keep empty in case it's referenced elsewhere
}

// Fix the loadAllAssets function to use window.enemyImage references:
// Replace your loadAllAssets function with this improved version:
function loadAllAssets() {
    // Reset the counter to make sure we start from 0
    assetsLoaded = 0;
    
    // Create a timeout safety mechanism
    const loadingTimeout = setTimeout(() => {
        console.log("Loading timeout - forcing game to start anyway");
        // Force set the exact count rather than incrementing
        assetsLoaded = totalAssets;
        showLoadingScreen(); // Update the loading screen one last time
        
        // Switch to start screen after a brief delay to show 100%
        setTimeout(() => {
            if (currentScreen === "loading") {
                switchScreen("start");
            }
        }, 500);
    }, 10000);
    
    if (!window.pendingScreenTimeouts) window.pendingScreenTimeouts = [];
	window.pendingScreenTimeouts.push(loadingTimeout);
    
    // Simple load function for each image
    function loadImage(img, src) {
        img.onload = function() { 
            assetLoaded(); 
            this.onload = null; 
        };
        img.onerror = function() { 
            console.error("Failed to load image:", src);
            assetLoaded(); 
            this.onerror = null; 
        };
        img.src = src;
    }
    // Ensure image objects are initialized before loading
	if (!window.startButtonImage) window.startButtonImage = new Image();
	if (!window.explosionImage) window.explosionImage = new Image();
	if (!window.enemyImage) window.enemyImage = new Image();
	if (!window.shootingEnemyImage) window.shootingEnemyImage = new Image();
	if (!window.circularEnemyImage) window.circularEnemyImage = new Image();
	if (!window.spinnerEnemyImage) window.spinnerEnemyImage = new Image();
	if (!window.powerupImage) window.powerupImage = new Image();
	if (!window.ohjusImage) window.ohjusImage = new Image();
	if (!window.bossImage) window.bossImage = new Image();
	if (!window.playerImage) window.playerImage = new Image();
	if (!window.logoImage) window.logoImage = new Image();
	if (!window.mainCharacterAnimImage) window.mainCharacterAnimImage = new Image();
	console.log("Image objects initialized for loading");
	
    // Load all images
	loadImage(window.startButtonImage, 'startbtn.png');
	loadImage(window.explosionImage, 'explo.png');
	// Add a special error handling for the start button
	// After loadImage(window.startButtonImage, 'startntn.png');
	window.startButtonImage.addEventListener('load', function() {
		console.log("Start button image loaded successfully:", this.width, "x", this.height);
		// Force start button update once loaded
		setTimeout(updateStartButton, 100);
	});

	window.startButtonImage.addEventListener('error', function() {
		console.error("Failed to load start button image - check path and file existence");
		// Create a fallback button
		const tempCanvas = document.createElement('canvas');
		tempCanvas.width = 670;
		tempCanvas.height = 4250;
		const tempCtx = tempCanvas.getContext('2d');
		
		// Create a simple green button as fallback (2 frames)
		for (let i = 0; i < 2; i++) {
			tempCtx.fillStyle = i === 0 ? '#4CAF50' : '#2E7D32';
			tempCtx.fillRect(0, i * 248, 670, 248);
			tempCtx.fillStyle = 'white';
			tempCtx.font = '40px Arial';
			tempCtx.textAlign = 'center';
			tempCtx.fillText('START GAME', 335, i * 248 + 124);
		}
		
		// Set the canvas as the source for the image
		this.src = tempCanvas.toDataURL();
	});
    loadImage(window.enemyImage, 'punatahti.png');
    loadImage(window.shootingEnemyImage, 'sinitahti.png');
    loadImage(window.circularEnemyImage, 'vihertahti.png');
    loadImage(window.spinnerEnemyImage, 'keltatahti.png');
    loadImage(window.powerupImage, 'powerup1.png');
    loadImage(window.bossImage, 'boss.png');
    loadImage(window.playerImage, 'alus1.png');
    loadImage(window.logoImage, 'LOGO.png');
	loadImage(window.mainCharacterAnimImage, 'alkuanim.png');
	loadImage(window.ohjusImage, 'ohjus.png');
    
    // Audio loading with simplified approach
    try {
        const tempAudio = new Audio();
        tempAudio.addEventListener('canplaythrough', function() {
            assetLoaded();
        }, {once: true});
        
        tempAudio.addEventListener('error', function() {
            console.log("Audio preload error - continuing anyway");
            assetLoaded();
        }, {once: true});
        
        // Shorter timeout for audio
        setTimeout(() => {
            if (assetsLoaded === totalAssets - 1) {
                console.log("Audio timeout - continuing anyway");
                assetLoaded();
            }
        }, 2000);
        
        tempAudio.src = 'tappaja1.mp3';
    } catch (e) {
        console.error("Audio preload error:", e);
        assetLoaded(); // Count as loaded even if it fails
    }
	const checkAssetsInterval = setInterval(() => {
		if (assetsLoaded >= totalAssets) {
			console.log("All assets loaded via interval check");
			clearInterval(checkAssetsInterval);
			
			// Switch to start screen after a brief delay
			setTimeout(() => {
				if (currentScreen === "loading") {
					isLoading = false;
					switchScreen("start");
				}
			}, 500);
		}
	}, 500);
}

// Add this at the end of your script block
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM loaded, initializing game...");
    
    // Force stable viewport height for DuckDuckGo and other mobile browsers
    function lockViewport() {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        
        // Force the same height consistently
        document.body.style.height = `${window.innerHeight}px`;
        document.documentElement.style.height = `${window.innerHeight}px`;
    }

    // Lock viewport on load and orientation change
    window.addEventListener('load', lockViewport);
    window.addEventListener('resize', lockViewport);
    window.addEventListener('orientationchange', lockViewport);

    // Call immediately
    lockViewport();
    
    // Force audio context creation to allow immediate playback later
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    window.gameAudioContext = audioContext;
    
    // Create a silent sound to unlock audio on iOS
    const silentSound = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    gainNode.gain.value = 0; // Silent
    silentSound.connect(gainNode);
    gainNode.connect(audioContext.destination);
    silentSound.start();
    silentSound.stop(audioContext.currentTime + 0.001);
    
    // Lock screen orientation for mobile devices
    if (detectMobile()) {
        lockScreenOrientation();
    }
	
	// Prevent page scrolling on mobile - only during gameplay
	document.addEventListener('touchmove', function(e) {
		if (isGameRunning && e.target === canvas) {
			e.preventDefault();
			e.stopPropagation();
			return false;
		}
	}, { passive: false });

	document.addEventListener('touchstart', function(e) {
		if (isGameRunning && e.target === canvas) {
			e.preventDefault();
			e.stopPropagation();
			return false;
		}
	}, { passive: false });

	// Prevent scroll on mouse wheel
	document.addEventListener('wheel', function(e) {
		e.preventDefault();
		return false;
	}, { passive: false });

	// Prevent scroll on arrow keys
	document.addEventListener('keydown', function(e) {
		if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
			e.preventDefault();
			return false;
		}
	}, { passive: false });
    
    // Initialize image objects
    window.enemyImage = new Image();
    window.shootingEnemyImage = new Image();
    window.circularEnemyImage = new Image();
    window.spinnerEnemyImage = new Image();
    window.powerupImage = new Image();
    window.bossImage = new Image();
    window.playerImage = new Image();
    window.logoImage = new Image();
	window.mainCharacterAnimImage = new Image();
	window.explosionImage = new Image();
	window.ohjusImage = new Image();
	
	// Ensure the start button image is initialized
	window.startButtonImage = window.startButtonImage || new Image();
    
    // Resize canvas to fit the device screen
    resizeCanvas();
    
    // Get references to DOM elements
    const startButton = document.getElementById('startButton');
    const restartButton = document.getElementById('restartButton');
    
    // Fix start button event listener
    // Set up start button canvas interaction
	const startButtonCanvas = document.getElementById('startButtonCanvas');
	if (startButtonCanvas) {
		// Mouse events for desktop
		startButtonCanvas.addEventListener('mousedown', function() {
			startButtonFrame = 1; // Show pressed frame
			updateStartButton();
		});

		startButtonCanvas.addEventListener('mouseup', function() {
			startButtonFrame = 0; // Show unpressed frame
			updateStartButton();
			// Start game after short delay
			setTimeout(() => {
				startGame();
			}, 500);
		});

		startButtonCanvas.addEventListener('mouseleave', function() {
			startButtonFrame = 0; // Reset to unpressed frame if mouse leaves
			updateStartButton();
		});

		// Touch events for mobile
		startButtonCanvas.addEventListener('touchstart', function(e) {
			e.preventDefault();
			startButtonFrame = 1; // Show pressed frame
			updateStartButton();
		});

		startButtonCanvas.addEventListener('touchend', function(e) {
			e.preventDefault();
			startButtonFrame = 0; // Show unpressed frame
			updateStartButton();
			// Start game after short delay
			setTimeout(() => {
				startGame();
			}, 500);
		});

		startButtonCanvas.addEventListener('touchcancel', function(e) {
			e.preventDefault();
			startButtonFrame = 0; // Reset to unpressed frame
			updateStartButton();
		});
		
		console.log("Start button canvas listeners added");
	} else {
		console.error("Start button canvas not found!");
	}
    
    // Set up restart button with the same hold-to-activate behavior
	const restartButtonCanvas = document.getElementById('restartButtonCanvas');
	if (restartButtonCanvas) {
		// Mouse events for desktop
		restartButtonCanvas.addEventListener('mousedown', function() {
			restartButtonFrame = 1; // Show pressed frame
			updateRestartButton();
		});

		restartButtonCanvas.addEventListener('mouseup', function() {
			restartButtonFrame = 0; // Show unpressed frame
			updateRestartButton();
			// Restart game after short delay
			setTimeout(() => {
				restartGame();
			}, 500);
		});

		restartButtonCanvas.addEventListener('mouseleave', function() {
			restartButtonFrame = 0; // Reset to unpressed frame if mouse leaves
			updateRestartButton();
		});

		// Touch events for mobile
		restartButtonCanvas.addEventListener('touchstart', function(e) {
			e.preventDefault();
			restartButtonFrame = 1; // Show pressed frame
			updateRestartButton();
		});

		restartButtonCanvas.addEventListener('touchend', function(e) {
			e.preventDefault();
			restartButtonFrame = 0; // Show unpressed frame
			updateRestartButton();
			// Restart game after short delay
			setTimeout(() => {
				restartGame();
			}, 500);
		});

		restartButtonCanvas.addEventListener('touchcancel', function(e) {
			e.preventDefault();
			restartButtonFrame = 0; // Reset to unpressed frame
			updateRestartButton();
		});
		
		console.log("Restart button canvas listeners added");
	}
    
    // Add window resize listener
    window.addEventListener('resize', function() {
        resizeCanvas();
    });
    
    // Start the loading process
    setTimeout(startLoading, 100);
});
// Handle safe areas for different mobile browsers
function updateSafeAreas() {
    // Get all screen elements
    const screens = document.querySelectorAll('.screen');
    
    // Check if running on iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    // Apply extra padding for iOS notch/dynamic island and bottom bar
    if (isIOS) {
        screens.forEach(screen => {
            screen.style.paddingTop = 'max(env(safe-area-inset-top), 40px)';
            screen.style.paddingBottom = 'max(env(safe-area-inset-bottom), 40px)';
        });
    }
    
    // Extra handling for bottom nav bars in browsers like Chrome
    const viewportHeight = window.innerHeight;
    if (viewportHeight < 600) {
        // For very small screens, reduce element sizes
        document.documentElement.style.setProperty('--scale-factor', '0.85');
    } else {
        document.documentElement.style.setProperty('--scale-factor', '1');
    }
}

// Call this function on load and resize
window.addEventListener('resize', updateSafeAreas);
document.addEventListener('DOMContentLoaded', updateSafeAreas);
document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    
    // Prevent scrolling with arrow keys and space
    if(['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
    }
});

document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

// Handle page visibility to prevent throttling
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'visible') {
        console.log("Page visible - resuming full performance");
        if (backgroundMusic && backgroundMusic.paused && isBackgroundMusicPlaying) {
            backgroundMusic.play();
        }
        lastTimeCheck = Date.now(); // Reset the time check to prevent time jump
    }
});


        let lastGroupSpawn = 0;
        const groupSpawnDelay = 15000; // Spawn group every 15 seconds
        // Player
        const player = {
	    x: canvas.width / 2,
	    y: canvas.height - 80,
	    size: 95,
	    hp: 100,
	    maxHp: 100,
	    bullets: [],
	    hitboxRatio: 0.6 // Hitbox is 60% of sprite size
	};
        // Game objects
        const enemies = [];
        const enemyBullets = [];
        let circularGroup = null;
        // Background stars
        const stars = [];
        const NUM_STARS = 100;
        // Initialize stars with different sizes and speeds
        for (let i = 0; i < NUM_STARS; i++) {
			stars.push({
				x: Math.random() * canvas.width,
				y: Math.random() * canvas.height,
				size: Math.random() * 2 + 0.5, // Stars of different sizes (0.5 to 2.5)
				speed: Math.random() * 0.3 + 0.1, // Very slow speeds (0.1 to 0.4)
				angle: Math.random() * Math.PI * 2, // Random starting rotation
				rotationSpeed: 0.01 + (Math.random() * 0.01) // Small positive rotation speed
			});
		}

function showLoadingScreen() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw loading text
    ctx.fillStyle = 'white';
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('LOADING...', canvas.width / 2, canvas.height / 2 - 50);
    
    // Draw loading bar background
    ctx.fillStyle = '#333';
    const barWidth = 200;
    const barHeight = 20;
    ctx.fillRect(canvas.width / 2 - barWidth / 2, canvas.height / 2, barWidth, barHeight);
    
    // Draw loading bar progress capped at 100%
    const progress = Math.min(assetsLoaded / totalAssets, 1);
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(canvas.width / 2 - barWidth / 2, canvas.height / 2, barWidth * progress, barHeight);
    
    // Draw percentage
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`${Math.min(Math.round(progress * 100), 100)}%`, canvas.width / 2, canvas.height / 2 + 40);
}

		// Create a function to initialize and play the music
// Modify the initializeMusic function
function initializeMusic() {
    // If music is already playing, don't initialize again
    if (isBackgroundMusicPlaying) {
        console.log("Music already playing, skipping initialization");
        return;
    }
    
    // For all devices - unified approach
    if (!backgroundMusic) {
        backgroundMusic = new Audio('tappaja1.mp3');
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.5;
        backgroundMusic.preload = 'auto'; // Ensure full preload
        
        // Set up seamless looping by detecting near-end
		backgroundMusic.addEventListener('timeupdate', function() {
			// If we're within 1 second of the end, restart earlier for seamless loop
			if (this.duration - this.currentTime < 3.0) {
				this.currentTime = 0;
			}
		});
        
        // Force playback repeatedly
        const forcePlay = () => {
            if (backgroundMusic && backgroundMusic.paused && isGameRunning) {
                backgroundMusic.play()
                .then(() => {
                    console.log("Audio successfully started");
                    isBackgroundMusicPlaying = true;
                })
                .catch(e => {
                    console.log("Audio start failed, retrying...");
                    // Try again in a short delay
                    setTimeout(forcePlay, 300);
                });
            }
        };
        
        // Try playing immediately
        forcePlay();
        
        // Also try playing on interactions
        document.addEventListener('click', forcePlay, {once: false});
        document.addEventListener('touchstart', forcePlay, {once: false});
        
        // Set a timeout to try playing again after 1 second
        setTimeout(forcePlay, 1000);
    } else if (backgroundMusic.paused) {
        backgroundMusic.play()
        .then(() => isBackgroundMusicPlaying = true)
        .catch(e => console.log("Could not resume audio:", e));
    }
}

// Additionally, ensure music is stopped when switching away from game
function stopMusic() {
    // Function intentionally left empty to keep music playing
    console.log("stopMusic called but ignored to keep music playing");
    return;
}

// Add this to handle game state transitions
function endGame() {
    isGameRunning = false;
    cancelAnimationFrame(gameLoop);
    finalScoreElement.textContent = score;
    gameStats.style.display = 'none';
    gameOverScreen.style.display = 'block';
    
    
    // Make sure the restart button is properly initialized
    restartButtonFrame = 0;
    
    // Use a longer delay to ensure DOM is fully updated before drawing
    setTimeout(function() {
        console.log("Initializing restart button after game over");
        updateRestartButton();
    }, 200); // Increased from 50ms to 200ms
}





        function updateStars() {
			stars.forEach(star => {
				star.y += star.speed;
				if (star.y > canvas.height) {
					star.y = 0;
					star.x = Math.random() * canvas.width;
				}
			});
		}

		function drawStars() {
			ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
			stars.forEach(star => {
				ctx.beginPath();
				ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
				ctx.fill();
			});
		}
		
        function drawStars() {
			stars.forEach(star => {
				// Save context for rotation
				ctx.save();
				ctx.translate(star.x, star.y);
				ctx.rotate(star.angle);
				
				// Draw a simple plus shape
				ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
				const size = star.size * 2; // Make stars a bit bigger for visibility
				
				// Horizontal line
				ctx.fillRect(-size, -size/4, size*2, size/2);
				
				// Vertical line
				ctx.fillRect(-size/4, -size, size/2, size*2);
				
				ctx.restore();
			});
		}
function initializeMainScreenStars() {
    // Clear existing stars
    mainScreenStars.length = 0;
    
    // Create new stars
    for (let i = 0; i < NUM_MAIN_SCREEN_STARS; i++) {
        mainScreenStars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 0.5, // Stars of different sizes (0.5 to 2.5)
            speedX: (Math.random() * 0.2) - 0.1, // Very slow diagonal movement
            speedY: Math.random() * 0.1 + 0.05,  // Slow downward movement
            angle: Math.random() * Math.PI * 2,  // Random starting rotation
            rotationSpeed: 0.01 + (Math.random() * 0.01) // Small rotation speed
        });
    }
}
function updateAndDrawMainScreenStars() {
    if (currentScreen !== "start") {
        // If we're not on the start screen, cancel the animation
        if (mainScreenStarsAnimationId) {
            cancelAnimationFrame(mainScreenStarsAnimationId);
            mainScreenStarsAnimationId = null;
        }
        return;
    }
    
    // Clear the entire canvas with the background color
    ctx.fillStyle = '#10164e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update and draw stars - make them brighter for better visibility
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Increased opacity for visibility
    mainScreenStars.forEach(star => {
        // Update position
        star.x += star.speedX;
        star.y += star.speedY;
        star.angle += star.rotationSpeed;
        
        // Wrap around if off screen
        if (star.x < 0) star.x = canvas.width;
        if (star.x > canvas.width) star.x = 0;
        if (star.y > canvas.height) star.y = 0;
        
        // Draw the star (using the same style as game stars but slightly larger)
        ctx.save();
        ctx.translate(star.x, star.y);
        ctx.rotate(star.angle);
        
        // Draw a simple plus shape - make it larger for better visibility
        const size = star.size * 3; // Increased size
        
        // Horizontal line
        ctx.fillRect(-size, -size/4, size*2, size/2);
        
        // Vertical line
        ctx.fillRect(-size/4, -size, size/2, size*2);
        
        ctx.restore();
    });
    
    // Continue the animation
    mainScreenStarsAnimationId = requestAnimationFrame(updateAndDrawMainScreenStars);
}
// Simple performance boost for mobile
function forceHighPerformance() {
    // Just a simple no-op function to avoid errors
    console.log("Forcing high performance mode");
    return;
}
function startGame() {
    console.log("Start game function called!");
	
	// Start the background music immediately
    initializeMusic();
    
    // Switch to game screen
    switchScreen("game");
    
    // Initialize game - using try/catch for better error handling
    try {
        // Add this line:
        forceHighPerformance();
        
        // Reset game state
        score = 0;
        gameTime = 0;
        lastTimeCheck = Date.now();
        bossSpawned = false;
        regularEnemiesDisabled = false;
        boss = null;
        explosionAnimation = null;
        
        // Set up game start sequence
        gameStartSequence = true;
        playerReady = false;
        enemySpawningActive = false;
        
        // Initialize device detection and controls
        isMobile = detectMobile();
        
        // Always create mobile controls - They'll only be visible on mobile
        createMobileControls();
        
        // Reset player - start fully below screen
		player.y = canvas.height + 100;
		player.x = canvas.width / 2;
        player.hp = player.maxHp;
        player.bullets = [];
        
        // Make player invulnerable until player becomes controllable
        playerInvulnerable = true;
        playerInvulnerableTimer = Date.now();
        
        // Clear enemies
        enemies.length = 0;
        enemyBullets.length = 0;
        circularGroup = null;
        lastGroupSpawn = Date.now();
        
        // Reset powerups
		rapidFireActive = false;
		rapidFireBulletsLeft = 0;
		dualFireActive = false;
		shieldActive = false;
		shieldHealth = 0;
		powerup = null;
		powerupSpawned = false;
        
        // Update UI
        scoreElement.textContent = score;
        hpElement.textContent = player.hp;
        
        // Enable player control and enemy spawning after delay
        setTimeout(() => {
            playerReady = true;
        }, 4000); // 4 seconds
        
        setTimeout(() => {
            enemySpawningActive = true;
        }, 5000); // 5 seconds
        
        // Start the game loop
		// Draw debug info if enabled
		if (DEBUG_MODE) {
			drawDebugInfo();
		}
		
        gameLoop = requestAnimationFrame(update);
        
        console.log("Game started successfully");
    } catch (e) {
        console.error("Error starting game:", e);
    }
}
function restartGame() {
    isGameRunning = true;
	// Reset mouse position to prevent unwanted movement
	mouseX = undefined;
	mouseY = undefined;
    score = 0;
    gameTime = 0;
    lastTimeCheck = Date.now();
    bossSpawned = false;
    regularEnemiesDisabled = false;
    boss = null;
    explosionAnimation = null; // Make sure this is here
    
    // Reset player position to match initial game start
	player.y = canvas.height + 100; // Start below the screen
	player.x = canvas.width / 2;    // Center horizontally
    player.hp = player.maxHp;
    player.bullets = [];
    
    // Set up game start sequence like in startGame
    gameStartSequence = true;
    playerReady = false;
    enemySpawningActive = false;
    
    // Make player invulnerable for the first 3 seconds
    playerInvulnerable = true;
    playerInvulnerableTimer = Date.now();
    
    enemies.length = 0;
    enemyBullets.length = 0;
    circularGroup = null;
    lastGroupSpawn = Date.now();
    
    // Reset powerups
	rapidFireActive = false;
	rapidFireBulletsLeft = 0;
	dualFireActive = false;
	shieldActive = false;
	shieldHealth = 0;
	powerup = null;
	powerupSpawned = false;
	// // Reset milestone tracking properly
	//for (let i = 0; i < reachedMilestones.length; i++) {
	//	reachedMilestones[i] = false;
	//}

    // Remove any existing powerup indicator
    const indicator = document.getElementById('powerupIndicator');
    if (indicator) {
        indicator.remove();
    }
    
    scoreElement.textContent = score;
    hpElement.textContent = player.hp;
    
    gameOverScreen.style.display = 'none';
    gameStats.style.display = 'block';
    
    // Enable player control and enemy spawning after delay - just like in startGame
    setTimeout(() => {
        playerReady = true;
    }, 4000); // 4 seconds
    
    setTimeout(() => {
        enemySpawningActive = true;
    }, 5000); // 5 seconds
    
    gameLoop = requestAnimationFrame(update);
}
		// Add this function to spawn the boss
		function spawnBoss() {
			bossSpawned = true;
			// regularEnemiesDisabled is now set earlier, we don't need to set it here
			lastBossMissile = Date.now();
			bossAnimationFrame = 0;  // Reset animation frame
			bossAnimationTimer = Date.now();  // Reset animation timer
			
			// Optional: Play a warning sound or add an on-screen warning
			// You could add a visual "Warning: Boss Approaching" message here
			
			boss = {
				x: canvas.width / 2,
				y: -150, // Start higher off-screen for more dramatic entrance
				width: 90,
				height: 90,
				hp: 450,
				maxHp: 450,
				lastShot: 0,
				shootingDelay: 1000, // 1 second
				moveDirection: 1,    // 1 for right, -1 for left
				moveSpeed: 1.5,
				movePattern: 0,      // Now 0: horizontal, 1: diagonal, 2: charge at player, 3: X-laser
				patternTimer: 0,     // For switching patterns
				patternDuration: 5000, // Switch pattern every 5 seconds
				entrySequence: true, // Flag for entry animation
				targetY: 100, // Target position for entry animation
				entrySpeed: 0.5, // Slower entry speed
				invulnerable: true, // Make boss invulnerable during entry
				flashEffect: 0, // For visual invulnerability effect
				
				// New laser pattern properties
				laserActive: false,
				laserAngle: 0,
				laserRotationSpeed: 0.015, // Radians per frame (faster rotation)
				laserRotationDirection: 1, // 1 for clockwise, -1 for counterclockwise
				laserWidth: 5,
				laserLength: 1000, // Long enough to reach screen edges
				laserDamage: 1, // Damage per frame while in contact with laser
				laserCooldown: false,
				laserCooldownTimer: 0,
				laserCooldownDuration: 1500, // 1.5 seconds cooldown
				laserStartupPhase: false,
				laserStartupTimer: 0,
				laserStartupDuration: 2000, // 2 seconds to prepare laser
				laserRotations: 0, // Track how many degrees we've rotated
				laserRotationLimit: Math.PI * 4 // Two full 360-degree rotations (720 degrees total)
			};
		}

		// Add this function to handle boss shooting
		function bossShooting() {
			if (!boss) return;
			
			// Don't shoot during entry sequence
			if (boss.entrySequence) return;
			
			const now = Date.now();
			
			// Regular shots
			if (now - boss.lastShot >= boss.shootingDelay) {
				// Three bullets in a spread pattern
				for (let i = -1; i <= 1; i++) {
					enemyBullets.push({
						x: boss.x + (i * 20),
						y: boss.y + boss.height / 2,
						width: 5,
						height: 10,
						speed: 3 + Math.random(),
						angle: Math.PI/2 + (i * Math.PI/12) // Spread pattern
					});
				}
				boss.lastShot = now;
			}
			
			// Missile shots
			if (now - lastBossMissile >= bossMissileDelay) {
				try {
					console.log("Creating boss missile...");
					// Create a missile enemy that follows the player
					const missile = {
						x: boss.x,
						y: boss.y + boss.height / 2,
						width: 25, // Larger to match the new image
						height: 25, // Larger to match the new image
						hp: 5,
						speed: 1.3,
						isMissile: true,
						points: 20,
						// Animation properties
						animFrame: 0,
						animTimer: now,
						isOhjus: true  // Flag to identify as ohjus missile
					};
					
					// Make sure all required properties are set
					if (isNaN(missile.x) || isNaN(missile.y)) {
						console.error("Invalid missile position:", missile.x, missile.y);
						// Use default values if boss position is invalid
						missile.x = canvas.width / 2;
						missile.y = 100;
					}
					
					enemies.push(missile);
					lastBossMissile = now;
					console.log("Missile created successfully");
				} catch (error) {
					console.error("Error creating boss missile:", error);
					lastBossMissile = now; // Still update timer to prevent continuous errors
				}
			}
		}

		// Add this function to update boss movement
		function updateBoss() {
			if (!boss) return;
			
			const now = Date.now();
			
			// Handle entry sequence first
			if (boss.entrySequence) {
				// Move boss down smoothly at slower speed
				boss.y += boss.entrySpeed;
				
				// Keep boss centered during entry
				boss.x = canvas.width / 2;
				
				// Update flash effect for invulnerability visualization
				boss.flashEffect = (boss.flashEffect + 0.1) % (Math.PI * 2);
				
				// Check if boss reached target position
				if (boss.y >= boss.targetY) {
					boss.y = boss.targetY;
					boss.entrySequence = false; // End entry sequence
					boss.patternTimer = now; // Start pattern timer now
					
					// Keep invulnerable for 2 more seconds after reaching position
					setTimeout(() => {
						if (boss) {
							boss.invulnerable = false;
						}
					}, 2000);
				}
				
				// Don't do normal movement or shooting during entry
				return;
			}
			
			
			// Normal boss behavior after entry sequence
			// Check if it's time to switch patterns
			if (!boss.laserActive && !boss.laserCooldown && !boss.laserStartupPhase && 
				now - boss.patternTimer >= boss.patternDuration) {
				// Randomly choose next pattern (60% chance for laser pattern)
				if (Math.random() < 0.60) {
					boss.movePattern = 3; // X-laser pattern
					boss.laserStartupPhase = true;
					boss.laserStartupTimer = now;
					boss.laserRotations = 0;
					boss.laserAngle = 0;
					// Randomly choose rotation direction: 50% chance for each direction
					boss.laserRotationDirection = Math.random() < 0.5 ? 1 : -1;
				} else {
					// Choose one of the original patterns
					boss.movePattern = Math.floor(Math.random() * 3); // 0, 1, or 2
				}
				boss.patternTimer = now;
			}

			// Handle laser cooldown
			if (boss.laserCooldown) {
				if (now - boss.laserCooldownTimer >= boss.laserCooldownDuration) {
					boss.laserCooldown = false;
					boss.movePattern = Math.floor(Math.random() * 3); // Go back to regular patterns
					boss.patternTimer = now; // Reset pattern timer
				}
				// During cooldown, just stay in place
				return;
			}

			// Handle laser startup phase
			if (boss.laserStartupPhase) {
				// Add pulsing red effect to entire screen as warning
				const progress = (now - boss.laserStartupTimer) / boss.laserStartupDuration;
				const pulse = Math.sin(now / 100) * 0.05;
				
				// Red flash warning - getting stronger as startup progresses
				ctx.fillStyle = `rgba(255, 0, 0, ${pulse * progress})`;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				
				// Add sound effect if progress is at certain thresholds
				if (progress > 0.25 && progress < 0.26 || 
					progress > 0.5 && progress < 0.51 ||
					progress > 0.75 && progress < 0.76) {
					// If you have a warning sound effect, play it here
					createExplosion(boss.x, boss.y, 0.5);
				}
				// Move to middle of the screen
				const targetX = canvas.width / 2;
				const targetY = canvas.height / 4; // 1/4 down from the top
				
				// Move towards target position
				const dx = targetX - boss.x;
				const dy = targetY - boss.y;
				
				boss.x += dx * 0.05; // Move 5% of the distance each frame
				boss.y += dy * 0.05;
				
				// Check if startup phase is complete
				if (now - boss.laserStartupTimer >= boss.laserStartupDuration &&
					Math.abs(dx) < 5 && Math.abs(dy) < 5) { // Close enough to target
					boss.laserStartupPhase = false;
					boss.laserActive = true;
					boss.x = targetX; // Snap to exact position
					boss.y = targetY;
					
					// Create charging effect
					for (let i = 0; i < 8; i++) {
						createExplosion(
							boss.x + Math.cos(i * Math.PI/4) * boss.width/2,
							boss.y + Math.sin(i * Math.PI/4) * boss.width/2,
							0.3
						);
					}
				}
				return;
			}

			// Handle active laser pattern
			if (boss.laserActive) {
				// Increase angle for rotation with direction
				boss.laserAngle += boss.laserRotationSpeed * boss.laserRotationDirection;
				boss.laserRotations += boss.laserRotationSpeed; // Always positive for tracking total rotation
				
				// Check if we've completed two full rotations
				if (boss.laserRotations >= boss.laserRotationLimit) {
					boss.laserActive = false;
					boss.laserCooldown = true;
					boss.laserCooldownTimer = now;
					return;
				}
				
				// Check for player collision with boss even during laser pattern
				const bossRadius = boss.width * 0.4;
				const playerRadius = player.size * player.hitboxRatio * 0.5;
				const distanceX = player.x - boss.x;
				const distanceY = player.y - boss.y;
				const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

				if (!playerInvulnerable && distance < (bossRadius + playerRadius)) {
					// Create explosion at collision point
					createExplosion(player.x, player.y, 1.0);

					// Calculate direction from boss to player
					const dx = player.x - boss.x;
					const dy = player.y - boss.y;
					const length = Math.sqrt(dx * dx + dy * dy);

					if (length > 0) {
						// Launch player away from boss
						const launchDistance = 300;
						const normalizedDx = dx / length;
						const normalizedDy = dy / length;
						
						// Calculate launch target position
						const launchTargetX = boss.x + normalizedDx * launchDistance;
						const launchTargetY = boss.y + normalizedDy * launchDistance;
						
						player.launchEffect = {
							startX: player.x,
							startY: player.y,
							targetX: Math.max(player.size/2, Math.min(canvas.width - player.size/2, launchTargetX)),
							targetY: Math.max(player.size/2, Math.min(canvas.height - player.size/2, launchTargetY)),
							startTime: Date.now(),
							duration: 500,
							controlsDisabled: true
						};
					} else {
						// If exactly on boss center, launch downward
						const launchTargetY = Math.min(canvas.height - player.size/2, boss.y + 300);
						
						player.launchEffect = {
							startX: player.x,
							startY: player.y,
							targetX: player.x,
							targetY: launchTargetY,
							startTime: Date.now(),
							duration: 500,
							controlsDisabled: true
						};
					}

					// Handle damage
					if (shieldActive) {
						shieldActive = false;
						createExplosion(player.x, player.y, 0.8);
					} else {
						player.hp -= 20;
						hpElement.textContent = player.hp;
					}

					playerInvulnerable = true;
					playerInvulnerableTimer = Date.now();
					bossCollisionInvulnerability = true;

					if (player.hp <= 0) {
						endGame();
					}
				}
				
				// Don't do regular movement or shooting during laser pattern
				return;
			}

			// Original patterns code here (patterns 0, 1, 2)
			if (boss.movePattern === 0) {
				// Horizontal movement
				boss.x += boss.moveSpeed * boss.moveDirection;
				
				// Bounce at edges
				if (boss.x > canvas.width - boss.width/2 || boss.x < boss.width/2) {
					boss.moveDirection *= -1;
				}
			}
			else if (boss.movePattern === 1) {
				// Diagonal movement
				boss.x += boss.moveSpeed * boss.moveDirection;
				boss.y += Math.sin(now / 500) * 2; // Wavy up-down movement
				
				// Bounce at edges
				if (boss.x > canvas.width - boss.width/2 || boss.x < boss.width/2) {
					boss.moveDirection *= -1;
				}
				
				// Keep within vertical bounds
				boss.y = Math.max(50, Math.min(canvas.height / 3, boss.y));
			}
			else if (boss.movePattern === 2) {
				// Charge at player pattern
				const dx = player.x - boss.x;
				const dy = player.y - boss.y;
				const distance = Math.sqrt(dx * dx + dy * dy);
				
				if (distance > 0) {
					boss.x += (dx / distance) * boss.moveSpeed * 0.5; // Slower charge
					boss.y += (dy / distance) * boss.moveSpeed * 0.5;
				}
				
				// Keep boss on screen
				boss.x = Math.max(boss.width/2, Math.min(canvas.width - boss.width/2, boss.x));
				boss.y = Math.max(50, Math.min(canvas.height / 2, boss.y));
			}
			
			// Boss shooting - only if not in laser mode
			if (boss.movePattern !== 3) {
				bossShooting();
			}
			
			// Calculate actual hitbox size for player
			const playerHitboxSize = player.size * player.hitboxRatio;
			
			// Check for player collision with boss using circular collision detection
			const bossRadius = boss.width * 0.4;
			const playerRadius = player.size * player.hitboxRatio * 0.5;
			const distanceX = player.x - boss.x;
			const distanceY = player.y - boss.y;
			const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

			if (!playerInvulnerable && distance < (bossRadius + playerRadius)) {
				// Create explosion at collision point
				createExplosion(player.x, player.y, 1.0);

				// Calculate direction from boss to player
				const dx = player.x - boss.x;
				const dy = player.y - boss.y;
				const length = Math.sqrt(dx * dx + dy * dy);

				if (length > 0) {
					// Launch player away from boss
					const launchDistance = 300;
					const normalizedDx = dx / length;
					const normalizedDy = dy / length;
					
					// Calculate launch target position
					const launchTargetX = boss.x + normalizedDx * launchDistance;
					const launchTargetY = boss.y + normalizedDy * launchDistance;
					
					player.launchEffect = {
						startX: player.x,
						startY: player.y,
						targetX: Math.max(player.size/2, Math.min(canvas.width - player.size/2, launchTargetX)),
						targetY: Math.max(player.size/2, Math.min(canvas.height - player.size/2, launchTargetY)),
						startTime: Date.now(),
						duration: 500, // 0.5 seconds
						controlsDisabled: true
					};
				} else {
					// If exactly on boss center, launch downward
					const launchTargetY = Math.min(canvas.height - player.size/2, boss.y + 300);
					
					player.launchEffect = {
						startX: player.x,
						startY: player.y,
						targetX: player.x,
						targetY: launchTargetY,
						startTime: Date.now(),
						duration: 500,
						controlsDisabled: true
					};
				}

				// Handle damage
				if (shieldActive) {
					shieldActive = false;
					createExplosion(player.x, player.y, 0.8);
				} else {
					player.hp -= 20;
					hpElement.textContent = player.hp;
				}

				playerInvulnerable = true;
				playerInvulnerableTimer = Date.now();
				bossCollisionInvulnerability = true;

				if (player.hp <= 0) {
					endGame();
				}
			}
		}

		// Add this function to draw the boss
		function drawBoss() {
			if (!boss) return;
			
			// Update animation frame
			const now = Date.now();
			if (now - bossAnimationTimer > bossFrameDuration) {
				bossAnimationFrame = (bossAnimationFrame + 1) % bossFrameCount;
				bossAnimationTimer = now;
			}
			
			// Add visual effects for entry and invulnerability
			if (boss.invulnerable) {
				// Save context for effects
				ctx.save();
				
				// Pulsing transparency effect for invulnerability
				ctx.globalAlpha = 0.6 + Math.sin(boss.flashEffect) * 0.3;
				
				// Optional: Add a glow effect for invulnerability
				ctx.shadowColor = "rgba(255, 255, 150, 0.8)";
				ctx.shadowBlur = 15 + Math.sin(boss.flashEffect * 2) * 5;
			}
			
			// Add charging effect during laser startup
			if (boss.laserStartupPhase) {
				// Pulsing red glow
				ctx.save();
				const progress = (Date.now() - boss.laserStartupTimer) / boss.laserStartupDuration;
				const pulseSize = 20 + Math.sin(Date.now() / 100) * 10;
				
				ctx.beginPath();
				ctx.arc(boss.x, boss.y, boss.width/2 + pulseSize * progress, 0, Math.PI * 2);
				ctx.fillStyle = `rgba(255, 0, 0, ${0.1 + 0.2 * progress})`;
				ctx.fill();
				
				// Add warning lines
				if (progress > 0.7) {
					ctx.lineWidth = 2;
					ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
					
					for (let i = 0; i < 4; i++) {
						const angle = (i * Math.PI/2);
						const endX = boss.x + Math.cos(angle) * (boss.width + 50);
						const endY = boss.y + Math.sin(angle) * (boss.width + 50);
						
						ctx.beginPath();
						ctx.moveTo(boss.x, boss.y);
						ctx.lineTo(endX, endY);
						ctx.stroke();
					}
				}
				
				ctx.restore();
			}
			
			// Draw boss with animation
			if (window.bossImage.complete) {
				// Calculate the source y position based on current frame
				// For vertical sprite sheet, x stays at 0 but y changes
				const sourceY = bossAnimationFrame * bossFrameHeight;
				
				// Draw the current frame
				ctx.drawImage(
					window.bossImage,
					0, sourceY, bossFrameWidth, bossFrameHeight, // Source rectangle (x, y, width, height)
					boss.x - boss.width/2, boss.y - boss.height/2,   // Destination position
					boss.width, boss.height                         // Destination size
				);
			} else {
				// Fallback if image isn't loaded
				ctx.fillStyle = '#ff0000';
				ctx.beginPath();
				ctx.arc(boss.x, boss.y, boss.width/2, 0, Math.PI * 2);
				ctx.fill();
				
				// Evil eyes
				ctx.fillStyle = 'black';
				ctx.beginPath();
				ctx.arc(boss.x - 15, boss.y - 10, 8, 0, Math.PI * 2);
				ctx.arc(boss.x + 15, boss.y - 10, 8, 0, Math.PI * 2);
				ctx.fill();
				
				// Evil mouth
				ctx.beginPath();
				ctx.arc(boss.x, boss.y + 10, 20, 0, Math.PI);
				ctx.stroke();
			}
			
			// Draw laser beams if active
			if (boss.laserActive) {
				drawBossLaser();
			}
			
			// Restore context if invulnerable effects were applied
			if (boss.invulnerable) {
				ctx.restore();
			}
			
			// Draw boss HP bar
			const hpBarWidth = boss.width * 1.5;
			const hpBarHeight = 8;
			const hpPercentage = boss.hp / boss.maxHp;
			
			// HP Bar background
			ctx.fillStyle = '#333';
			ctx.fillRect(boss.x - hpBarWidth/2, boss.y - boss.height/2 - 15, hpBarWidth, hpBarHeight);
			
			// HP Bar fill
			ctx.fillStyle = `rgb(${255 * (1 - hpPercentage)}, ${255 * hpPercentage}, 0)`;
			ctx.fillRect(boss.x - hpBarWidth/2, boss.y - boss.height/2 - 15, hpBarWidth * hpPercentage, hpBarHeight);
		}
		function drawBossLaser() {
			if (!boss || !boss.laserActive) return;
			
			// Save context
			ctx.save();
			
			// Set laser style
			ctx.lineWidth = boss.laserWidth;
			ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; // Red laser
			ctx.shadowColor = 'rgba(255, 50, 50, 0.9)';
			ctx.shadowBlur = 15;
			
			// Calculate center point for rotation
			const centerX = boss.x;
			const centerY = boss.y;
			
			// Draw four lines in X pattern
			for (let i = 0; i < 4; i++) {
				const angle = boss.laserAngle + (i * Math.PI/2); // 4 lines at 90-degree intervals
				
				// Calculate end points
				const endX = centerX + Math.cos(angle) * boss.laserLength;
				const endY = centerY + Math.sin(angle) * boss.laserLength;
				
				// Draw laser beam
				ctx.beginPath();
				ctx.moveTo(centerX, centerY);
				ctx.lineTo(endX, endY);
				ctx.stroke();
				
				// Add a glow effect
				ctx.lineWidth = boss.laserWidth * 2;
				ctx.strokeStyle = 'rgba(255, 0, 0, 0.2)';
				ctx.beginPath();
				ctx.moveTo(centerX, centerY);
				ctx.lineTo(endX, endY);
				ctx.stroke();
			}
			
			// Restore context
			ctx.restore();
		}
		
		function checkLaserCollision() {
			if (!boss || !boss.laserActive || playerInvulnerable) return false;
			
			// Calculate actual hitbox size for player
			const playerHitboxSize = player.size * player.hitboxRatio;
			const playerX = player.x;
			const playerY = player.y;
			const playerRadius = playerHitboxSize / 2;
			
			// Check collision with each of the 4 laser beams
			for (let i = 0; i < 4; i++) {
				const angle = boss.laserAngle + (i * Math.PI/2);
				
				// Parametric line equation for the laser
				const laserStartX = boss.x;
				const laserStartY = boss.y;
				const laserDirX = Math.cos(angle);
				const laserDirY = Math.sin(angle);
				
				// Calculate closest point on line to player center
				const t = ((playerX - laserStartX) * laserDirX + (playerY - laserStartY) * laserDirY) /
						 (laserDirX * laserDirX + laserDirY * laserDirY);
				
				// Find the closest point on the line
				const closestX = laserStartX + t * laserDirX;
				const closestY = laserStartY + t * laserDirY;
				
				// Check if closest point is within laser length
				const distanceToLaserStart = Math.sqrt(
					(closestX - laserStartX) * (closestX - laserStartX) +
					(closestY - laserStartY) * (closestY - laserStartY)
				);
				
				if (distanceToLaserStart <= boss.laserLength) {
					// Check if player is close enough to the laser line
					const distanceToPlayer = Math.sqrt(
						(closestX - playerX) * (closestX - playerX) +
						(closestY - playerY) * (closestY - playerY)
					);
					
					// If distance less than player radius + laser width/2, we have a hit
					if (distanceToPlayer <= playerRadius + boss.laserWidth/2) {
						return true;
					}
				}
			}
			
			return false;
		}
// Add this function to animate the main character on the start screen
function animateMainCharacter() {
    if (currentScreen !== "start") return;
    
    const animCanvas = document.getElementById('characterAnimCanvas');
    if (!animCanvas) return;
    
    const animCtx = animCanvas.getContext('2d');
    
    // Update animation frame
    const now = Date.now();
    if (now - mainCharacterAnimTimer > mainCharacterFrameDuration) {
        mainCharacterAnimFrame = (mainCharacterAnimFrame + 1) % mainCharacterFrameCount;
        mainCharacterAnimTimer = now;
    }
    
    // Clear the canvas - don't clear it here as we're using the stars as background
    animCtx.clearRect(0, 0, animCanvas.width, animCanvas.height);
    
    // Draw the current frame if image is loaded
    if (window.mainCharacterAnimImage.complete) {
        // Draw the current frame from the sprite sheet
        animCtx.drawImage(
            window.mainCharacterAnimImage,
            0, mainCharacterAnimFrame * (mainCharacterFrameHeight / mainCharacterFrameCount), 
            mainCharacterFrameWidth, mainCharacterFrameHeight / mainCharacterFrameCount,
            0, 0,
            animCanvas.width, animCanvas.height
        );
    }
    
    // Continue animation
    requestAnimationFrame(animateMainCharacter);
	// Initialize the start button too
    updateStartButton();
}
function updateStartButton() {
    // Ensure start button image exists
    if (!window.startButtonImage) {
        window.startButtonImage = new Image();
        window.startButtonImage.src = 'startbtn.png';
        console.log("Created missing start button image");
    }
    if (!window.startButtonImage || !window.startButtonImage.complete) {
        console.log("Start button image not ready yet");
        // Try again in a moment
        setTimeout(updateStartButton, 100);
        return;
    }
    
    const buttonCanvas = document.getElementById('startButtonCanvas');
    if (!buttonCanvas) {
        console.error("Start button canvas not found");
        return;
    }
    
    // Get the canvas context and clear it
    const buttonCtx = buttonCanvas.getContext('2d');
    buttonCtx.clearRect(0, 0, buttonCanvas.width, buttonCanvas.height);
    
    // Calculate frame position in the sprite sheet (2 frames vertically)
    const frameWidth = 670;
    const frameHeight = 248;
    
    try {
        // Draw the current frame (0 = up, 1 = down)
        buttonCtx.drawImage(
            window.startButtonImage,
            0, startButtonFrame * frameHeight, 
            frameWidth, frameHeight,        
            0, 0,                          
            buttonCanvas.width, buttonCanvas.height
        );
        
    } catch (e) {
        console.error("Error drawing start button:", e);
        // Fallback drawing code
        buttonCtx.fillStyle = '#4CAF50';
        buttonCtx.fillRect(0, 0, buttonCanvas.width, buttonCanvas.height);
        buttonCtx.fillStyle = 'white';
        buttonCtx.font = '20px Arial';
        buttonCtx.textAlign = 'center';
        buttonCtx.fillText('START GAME', buttonCanvas.width/2, buttonCanvas.height/2 + 7);
    }
}
function updateRestartButton() {
    console.log("updateRestartButton called, canvas exists:", !!document.getElementById('restartButtonCanvas'));
    
    if (!window.startButtonImage || !window.startButtonImage.complete) {
        console.log("Button image not ready yet for restart button");
        // Try again in a moment
        setTimeout(updateRestartButton, 100);
        return;
    }
    
    const buttonCanvas = document.getElementById('restartButtonCanvas');
    if (!buttonCanvas) {
        console.error("Restart button canvas not found");
        return;
    }
    
    // Get the canvas context and clear it
    const buttonCtx = buttonCanvas.getContext('2d');
    buttonCtx.clearRect(0, 0, buttonCanvas.width, buttonCanvas.height);
    
    // Calculate frame position in the sprite sheet (2 frames vertically)
    const frameWidth = 670;
    const frameHeight = 248;
    
    try {
        // Draw the current frame (0 = up, 1 = down)
        buttonCtx.drawImage(
            window.startButtonImage,
            0, restartButtonFrame * frameHeight, 
            frameWidth, frameHeight,
            0, 0,
            buttonCanvas.width, buttonCanvas.height
        );
        
    } catch (e) {
        console.error("Error drawing restart button:", e);
        // Fallback if drawing fails
        buttonCtx.fillStyle = '#4CAF50';
        buttonCtx.fillRect(0, 0, buttonCanvas.width, buttonCanvas.height);
        buttonCtx.fillStyle = 'white';
        buttonCtx.font = '20px Arial';
        buttonCtx.textAlign = 'center';
        buttonCtx.fillText('RESTART GAME', buttonCanvas.width/2, buttonCanvas.height/2 + 7);
    }
}
function createExplosion(x, y, size = 1.0) {
    // Create a new explosion at the given coordinates
    // size parameter controls how big the explosion appears (1.0 = normal, 0.5 = half size)
    explosions.push({
        x: x,
        y: y,
        frame: 0,
        startTime: Date.now(),
        active: true,
        size: size
    });
}
function updateAndDrawExplosions() {
    const now = Date.now();
    
    // Loop through all active explosions
    for (let i = explosions.length - 1; i >= 0; i--) {
        const explosion = explosions[i];
        
        // Calculate progress through animation
        const elapsed = now - explosion.startTime;
        const progress = Math.min(elapsed / explosionDuration, 1);
        
        // Calculate current frame based on progress
        explosion.frame = Math.min(Math.floor(progress * explosionFrameCount), explosionFrameCount - 1);
        
        // Draw the current explosion frame
        if (window.explosionImage.complete) {
            ctx.drawImage(
				window.explosionImage,
				0, explosion.frame * explosionFrameHeight, 
				explosionFrameWidth, explosionFrameHeight,
				explosion.x - (explosionFrameWidth/4 * explosion.size), 
				explosion.y - (explosionFrameHeight/4 * explosion.size),
				explosionFrameWidth/2 * explosion.size, 
				explosionFrameHeight/2 * explosion.size
			);
        }
        
        // Remove explosion if animation is complete
        if (progress >= 1) {
            explosions.splice(i, 1);
        }
    }
}
function endGame() {
    isGameRunning = false;
    cancelAnimationFrame(gameLoop);
    finalScoreElement.textContent = score;
    gameStats.style.display = 'none';
    gameOverScreen.style.display = 'block';
    
    
    // Make sure the restart button is properly initialized
    restartButtonFrame = 0;
    restartButtonAnimating = false;
    
    // Use a longer delay to ensure DOM is fully updated before drawing
    setTimeout(function() {
        console.log("Initializing restart button after game over");
        updateRestartButton();
        
        // Call it again after a short delay to ensure it's visible
        setTimeout(updateRestartButton, 100);
    }, 300);
}
        function spawnCircularGroup() {
            const groupCenterX = canvas.width / 2;
            const groupCenterY = -140;
            const radius = 140;
            
            circularGroup = {
                centerX: groupCenterX,
                centerY: groupCenterY,
                radius: radius,
                angle: 0,
                rotationSpeed: 0.012,
                moveSpeed: 0.5,
                members: []
            };
            // Spawn 10 enemies in a circle
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                const enemy = {
                    baseAngle: angle,
                    x: groupCenterX + Math.cos(angle) * radius,
                    y: groupCenterY + Math.sin(angle) * radius,
                    width: 22,
                    height: 22,
                    hp: 2,
                    points: 15,
                    isCircular: true
                };
                circularGroup.members.push(enemy);
                enemies.push(enemy);
            }
        }
        function updateCircularGroup() {
            if (!circularGroup) return;
            // Update group position
            circularGroup.centerY += circularGroup.moveSpeed;
            circularGroup.angle += circularGroup.rotationSpeed;
            // Update each member's position
            circularGroup.members.forEach((enemy, index) => {
                const angle = enemy.baseAngle + circularGroup.angle;
                enemy.x = circularGroup.centerX + Math.cos(angle) * circularGroup.radius;
                enemy.y = circularGroup.centerY + Math.sin(angle) * circularGroup.radius;
            });
            // Remove group if it's off screen
            if (circularGroup.centerY > canvas.height + circularGroup.radius * 2) {
                circularGroup.members.forEach(member => {
                    const index = enemies.indexOf(member);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                });
                circularGroup = null;
            }
            // Or if all members are destroyed
            else if (circularGroup.members.every(m => !enemies.includes(m))) {
                circularGroup = null;
            }
        }
        function spawnEnemy() {
			// Check if it's time to spawn a circular group
			const now = Date.now();
			if (!circularGroup && now - lastGroupSpawn >= groupSpawnDelay && gameTime >= 36) {
				spawnCircularGroup();
				lastGroupSpawn = now;
				return;
			}
			
			// Check if game time is past 10 seconds for shooting enemies
			const canSpawnShootingEnemy = gameTime >= 10;
			
			// Regular enemy spawn logic - only allow shooting enemies after 10 seconds
			const isShootingEnemy = canSpawnShootingEnemy && Math.random() < 0.3;
			
			// Add margin to prevent enemies from spawning too close to the edges
			const edgeMargin = 40;
			
			const enemy = {
				x: edgeMargin + Math.random() * (canvas.width - (edgeMargin * 2)),
				y: -20,
				width: 22,
				height: 22,
				speed: isShootingEnemy ? 0.8 : 1.1,
				hp: isShootingEnemy ? 2 : 2,
				points: isShootingEnemy ? 20 : 10,
				isShooting: isShootingEnemy,
				lastShot: 0,
				shootingDelay: 2000,
				// Add rotation properties
				angle: 0,
				rotationSpeed: (Math.random() * 0.05) + 0.01, // Small random rotation speed
				hitboxScale: 1.5 // Make hitbox 1.5x larger than visual
			};
			enemies.push(enemy);
		}
		// Add this function to spawn the powerup
function spawnPowerup(x, y) {
    // Don't spawn if another powerup already exists
    if (powerup) return;
    // Calculate available powerup types based on what player already has
    let availableTypes = [];
    let totalChance = 0;
    
    // Only add powerup types that player doesn't already have
    if (!dualFireActive) {
        availableTypes.push({
            type: POWERUP_TYPES.DUAL_FIRE,
            chance: POWERUP_TYPES.DUAL_FIRE.chance
        });
        totalChance += POWERUP_TYPES.DUAL_FIRE.chance;
    }
    
    if (!shieldActive) {
        availableTypes.push({
            type: POWERUP_TYPES.SHIELD,
            chance: POWERUP_TYPES.SHIELD.chance
        });
        totalChance += POWERUP_TYPES.SHIELD.chance;
    }
    
    // Only add Rapid Fire if player doesn't already have it
	if (!rapidFireActive) {
		availableTypes.push({
			type: POWERUP_TYPES.RAPID_FIRE,
			chance: POWERUP_TYPES.RAPID_FIRE.chance
		});
		totalChance += POWERUP_TYPES.RAPID_FIRE.chance;
	}
    
    // If no powerups are available (player has everything), don't spawn
    if (availableTypes.length === 0 || totalChance === 0) {
        return;
    }
    
    // Randomly select a powerup type based on available chances
    let random = Math.random() * totalChance;
    let selectedType = null;
    
    for (let i = 0; i < availableTypes.length; i++) {
        random -= availableTypes[i].chance;
        if (random <= 0) {
            selectedType = availableTypes[i].type;
            break;
        }
    }
    
    // Fallback if no type selected (shouldn't happen)
    if (!selectedType) {
        selectedType = availableTypes[0].type;
    }
    
    powerup = {
        x: x,
        y: y,
        width: 30, // Slightly larger
        height: 30, // Slightly larger
        speed: 1.2,
        type: selectedType.id,
        spawnTime: Date.now() // Track when it was spawned
    };
    
    powerupSpawned = true;
}

function updatePowerup() {
    if (!powerup) return;
    
    powerup.y += powerup.speed;
    
    // Check if player collected the powerup
    if (checkCollision(powerup, {
        x: player.x - player.size/2,
        y: player.y - player.size/2,
        width: player.size,
        height: player.size
    })) {
        // Handle different powerup types
		let appliedPowerup = true;
		let pointsAwarded = 0; // Add this line

		switch(powerup.type) {
			case POWERUP_TYPES.RAPID_FIRE.id:
				// Always apply rapid fire
				rapidFireActive = true;
				rapidFireBulletsLeft = 100;
				pointsAwarded = 200;
				break;
                
            case POWERUP_TYPES.SHIELD.id:
                // Only apply shield if player doesn't already have one
                if (!shieldActive) {
                    shieldActive = true;
                    shieldHealth = 1;
					pointsAwarded = 200;
                } else {
                    // Already has shield, give points instead
                    pointsAwarded = 200;
                    appliedPowerup = false;
                }
                break;
                
            case POWERUP_TYPES.DUAL_FIRE.id:
                // Always apply dual fire (stacks with rapid fire)
                dualFireActive = true;
				pointsAwarded = 200;
                break;
        }
		
		// Add points based on what happened
		score += pointsAwarded;
		scoreElement.textContent = score;
        
        // Show pickup effect
        createExplosion(powerup.x, powerup.y, 0.5);
        
        // Show what powerup was collected
        if (appliedPowerup) {
            let message = "";
            switch(powerup.type) {
                case POWERUP_TYPES.RAPID_FIRE.id:
                    message = "RAPID FIRE!";
                    break;
                case POWERUP_TYPES.SHIELD.id:
                    message = "SHIELD!";
                    break;
                case POWERUP_TYPES.DUAL_FIRE.id:
                    message = "DUAL FIRE!";
                    break;
            }
            
            // Show floating text
            // (Could implement this later)
        }
        
        // Remove the powerup
        powerup = null;
    }
    
    // Remove if offscreen
    if (powerup && powerup.y > canvas.height) {
        powerup = null;
    }
}

	// Add this function to draw the powerup
function drawPowerup() {
    if (!powerup) return;
    
    // Save the context for transformations
    ctx.save();
    
    // Get color based on powerup type
    let powerupColor;
    switch(powerup.type) {
        case POWERUP_TYPES.RAPID_FIRE.id:
            powerupColor = POWERUP_TYPES.RAPID_FIRE.color; // Gold/yellow
            break;
        case POWERUP_TYPES.SHIELD.id:
            powerupColor = POWERUP_TYPES.SHIELD.color; // Blue
            break;
        case POWERUP_TYPES.DUAL_FIRE.id:
            powerupColor = POWERUP_TYPES.DUAL_FIRE.color; // Purple/Magenta
            break;
        default:
            powerupColor = '#FFFFFF';
    }
    
    // Add a pulsing glow effect
    ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 150) * 0.3;
    
    // Draw the powerup with colored tint
    if (window.powerupImage && window.powerupImage.complete) {
        // First draw a colored glow underneath
        ctx.beginPath();
        ctx.arc(powerup.x, powerup.y, powerup.width * 1.2, 0, Math.PI * 2);
        ctx.fillStyle = powerupColor;
        ctx.fill();
        
        // Draw the actual powerup image
        ctx.globalAlpha = 1.0;
        ctx.drawImage(
            window.powerupImage,
            powerup.x - powerup.width/2,
            powerup.y - powerup.width/2,
            powerup.width,
            powerup.width
        );
        
        // Apply a color overlay
        ctx.globalCompositeOperation = 'color';
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = powerupColor;
        ctx.fillRect(
            powerup.x - powerup.width/2,
            powerup.y - powerup.width/2,
            powerup.width,
            powerup.width
        );
    } else {
        // Fallback if image isn't loaded
        ctx.beginPath();
        ctx.arc(powerup.x, powerup.y, powerup.width/2, 0, Math.PI * 2);
        ctx.fillStyle = powerupColor;
        ctx.fill();
    }
    
    // Restore the context
    ctx.restore();
}

	// Modify the shoot function to handle rapid fire
	function shoot() {
		const now = Date.now();
		const currentShootingDelay = rapidFireActive ? rapidFireShootingDelay : shootingDelay;
		
		if (now - lastShot >= currentShootingDelay) {
			// Different shooting patterns based on active powerups
			if (dualFireActive) {
				// Dual fire - two bullets side by side
				const offset = 8; // Space between bullets
				player.bullets.push({
					x: player.x - offset,
					y: player.y,
					width: 3,
					height: 8,
					speed: 7
				});
				player.bullets.push({
					x: player.x + offset,
					y: player.y,
					width: 3,
					height: 8,
					speed: 7
				});
			} else {
				// Regular single fire
				player.bullets.push({
					x: player.x,
					y: player.y,
					width: 3,
					height: 8,
					speed: 7
				});
			}
			
			lastShot = now;
			
			// Track rapid fire bullets
			if (rapidFireActive) {
				rapidFireBulletsLeft--;
				
				// End powerup if bullets are used up
				if (rapidFireBulletsLeft <= 0) {
					rapidFireActive = false;
				}
			}
		}
	}

        function enemyShoot(enemy) {
            const now = Date.now();
            if (now - enemy.lastShot >= enemy.shootingDelay) {
                enemyBullets.push({
                    x: enemy.x + enemy.width / 2,
                    y: enemy.y + enemy.height,
                    width: 6,
                    height: 12,
                    speed: 2.5
                });
                enemy.lastShot = now;
            }
        }
        
function updateBullets() {
    for (let i = player.bullets.length - 1; i >= 0; i--) {
        const bullet = player.bullets[i];
        bullet.y -= bullet.speed;
        
        if (bullet.y < 0) {
            player.bullets.splice(i, 1);
            continue;
        }
        
        // Check for boss hit
		if (boss && checkCollision(bullet, {
			x: boss.x - boss.width/2,
			y: boss.y - boss.height/2,
			width: boss.width,
			height: boss.height
		})) {
			// Create a small explosion where the bullet hit regardless of invulnerability
			createExplosion(bullet.x, bullet.y, 0.4);
			player.bullets.splice(i, 1);
			
			// Only damage the boss if not invulnerable
			if (!boss.invulnerable) {
				boss.hp--;
				
				// Boss death
				if (boss.hp <= 0) {
					// Start explosion animation instead of instant damage
					explosionAnimation = {
						centerX: boss.x,
						centerY: boss.y,
						radius: 10,
						startTime: Date.now(),
						duration: 5000, // 5 seconds
						completed: false
					};
					
					boss = null;
					score += 1000; // Big points for defeating boss
					continue;
				}
			}
			continue;
}
        
        // Regular enemy hit check
        // Regular enemy hit check
		for (let j = enemies.length - 1; j >= 0; j--) {
			const enemy = enemies[j];
			
			// Apply larger hitbox for enemy collision
			let hitboxWidth = enemy.width;
			let hitboxHeight = enemy.height;
			
			// Apply larger hitbox for non-spinner enemies
			if (!enemy.isSpinner && !enemy.isMissile) {
				hitboxWidth *= enemy.hitboxScale || 1.5;
				hitboxHeight *= enemy.hitboxScale || 1.5;
			}
			
			if (checkCollision(bullet, {
				x: enemy.x - hitboxWidth/2,
				y: enemy.y - hitboxHeight/2,
				width: hitboxWidth,
				height: hitboxHeight
			})) {
				enemy.hp--;
				// Create a small explosion where the bullet hit
				createExplosion(bullet.x, bullet.y, 0.4);
				player.bullets.splice(i, 1);
				
				if (enemy.hp <= 0) {
					score += enemy.points;
					scoreElement.textContent = score;
					
					// Chance to spawn a powerup ONLY when defeating an enemy with bullets
					// (not by collision with player) AND no other powerup is on screen
					if (!powerup && Math.random() < POWERUP_SPAWN_RATE) {
						spawnPowerup(enemy.x, enemy.y);
					}
					
					enemies.splice(j, 1);
					if (circularGroup) {
						circularGroup.members = circularGroup.members.filter(m => m !== enemy);
					}
				}
				break;
			}
		}
    }
}
function updateEnemyBullets() {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        bullet.y += bullet.speed;
        
        if (bullet.y > canvas.height) {
            enemyBullets.splice(i, 1);
            continue;
        }
        
        // Calculate actual hitbox size for player
	const playerHitboxSize = player.size * player.hitboxRatio;
	
	// Check player collision with bullet using adjusted hitbox
	if (!playerInvulnerable && checkCollision(bullet, {
	    x: player.x - playerHitboxSize/2,
	    y: player.y - playerHitboxSize/2,
	    width: playerHitboxSize,
	    height: playerHitboxSize
	})) {
			// Check if shield is active
			if (shieldActive) {
				// Shield absorbs the hit
				shieldActive = false;
				createExplosion(player.x, player.y, 0.8); // Shield break effect
			} else {
				// No shield, take damage normally
				player.hp -= 5; // Bullet damage
			}
			// Create a small explosion where the bullet hit
			createExplosion(bullet.x, bullet.y, 0.5);
            hpElement.textContent = player.hp;
            enemyBullets.splice(i, 1);
            
            if (player.hp <= 0) {
                endGame();
            }
        }
    }
}
 
		function updateExplosion() {
    if (!explosionAnimation) return;
    
    const now = Date.now();
    const elapsed = now - explosionAnimation.startTime;
    const progress = Math.min(elapsed / explosionAnimation.duration, 1);
	
	// If animation is complete, don't render anything else
    if (progress >= 1) {
        if (!explosionAnimation.completed) {
            explosionAnimation.completed = true;
            
            // Defeat player when animation completes
            player.hp -= 100;
            hpElement.textContent = player.hp;
            if (player.hp <= 0) {
                endGame();
            }
        }
        // Don't continue with rendering if animation is done
        return;
    }
    
    // Calculate expanding radius - make it larger to ensure it covers the whole screen
    const maxRadius = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) * 1.5;
    explosionAnimation.radius = progress * maxRadius;
    
    // Create a brighter, more intense explosion
    // Start with pure white, then add a yellow/orange glow at the end
    const brightness = 1 - (progress * 0.3); // Stays brighter longer
    
    // Create a pulsing effect for added intensity
    const pulse = Math.sin(progress * 10) * 0.1 * (1 - progress) + 1;
	
    // Draw the explosion in a layer above everything else
    // First draw a bright white center that covers the entire screen
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness * pulse})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height); // Cover the entire screen	
    
    // Then draw the expanding circle with a glow
    const gradient = ctx.createRadialGradient(
        explosionAnimation.centerX, explosionAnimation.centerY, 0,
        explosionAnimation.centerX, explosionAnimation.centerY, explosionAnimation.radius
    );
    
    gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness * 0.9})`);
    gradient.addColorStop(0.6, `rgba(255, 255, 200, ${brightness * 0.7})`);
    gradient.addColorStop(0.8, `rgba(255, 170, 100, ${brightness * 0.5})`);
    gradient.addColorStop(1, `rgba(255, 100, 50, ${brightness * 0.3})`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(explosionAnimation.centerX, explosionAnimation.centerY, 
            explosionAnimation.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Add visual feedback - random smaller "sparkles" for dramatic effect
    if (progress < 0.8) {
        for (let i = 0; i < 5; i++) {
            const sparkX = explosionAnimation.centerX + (Math.random() - 0.5) * explosionAnimation.radius * progress;
            const sparkY = explosionAnimation.centerY + (Math.random() - 0.5) * explosionAnimation.radius * progress;
            const sparkSize = 20 + Math.random() * 50;
            
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Check if animation is complete
    if (elapsed >= explosionAnimation.duration && !explosionAnimation.completed) {
        explosionAnimation.completed = true;
        
        // Defeat player when animation completes
        player.hp -= 100;
        if (player.hp <= 0) {
            endGame();
        }
    }
}
        function updateEnemies() {
			// Only spawn regular enemies if boss isn't active, not disabled, and enemy spawning is active
			if (enemySpawningActive && !regularEnemiesDisabled && enemies.length < 5 && Math.random() < 0.02) {
				// Check if game time is past 1 minute (60 seconds) and add chance for spinner
				if (gameTime >= 60 && Math.random() < 0.2) { // 20% chance to spawn spinner instead of regular enemy
					// Spawn spinner enemy
					const spinnerEnemy = {
						x: Math.random() * (canvas.width - 30) + 15,
						y: 60, // Slightly below the top
						width: 24,
						height: 24,
						hp: 8, // Tougher than regular enemies
						speed: 4, // Fast when launched
						points: 50, // Worth more points
						isSpinner: true,
						spinTimer: Date.now(),
						spinDuration: 3000, // 3 seconds of spinning
						angle: 0, // Current rotation angle
						launched: false
					};
					enemies.push(spinnerEnemy);
				} else {
					spawnEnemy();
				}
			}
			
			updateCircularGroup();
			
			for (let i = enemies.length - 1; i >= 0; i--) {
				const enemy = enemies[i];
				
				if (!enemy.isSpinner) { // Don't modify spinner enemies since they have their own rotation
					enemy.angle += enemy.rotationSpeed;
				}
				
				if (enemy.isSpinner) {
					// Increase rotation angle
					enemy.angle += 0.1; // Rotation speed
					
					// Check if it's time to launch
					const now = Date.now();
					if (!enemy.launched && now - enemy.spinTimer >= enemy.spinDuration) {
						enemy.launched = true;
						
						// Calculate direction to player
						const dx = player.x - enemy.x;
						const dy = player.y - enemy.y;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						// Store normalized direction
						if (distance > 0) {
							enemy.dirX = dx / distance;
							enemy.dirY = dy / distance;
						} else {
							enemy.dirX = 0;
							enemy.dirY = 1; // Default downward
						}
					}
					
					// Move if launched
					if (enemy.launched) {
						enemy.x += enemy.dirX * enemy.speed;
						enemy.y += enemy.dirY * enemy.speed;
					}
				}
				else if (enemy.isMissile) {
					// Calculate direction to player for homing
					const dx = player.x - enemy.x;
					const dy = player.y - enemy.y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					
					// Update position
					if (distance > 0) {
						enemy.x += (dx / distance) * enemy.speed;
						enemy.y += (dy / distance) * enemy.speed;
					} else {
						enemy.y += enemy.speed;
					}
					
					// Update animation frame for ohjus missiles
					try {
						if (enemy.isOhjus) {
							const now = Date.now();
							if (!enemy.animTimer) enemy.animTimer = now;
							if (!enemy.animFrame) enemy.animFrame = 0;
							
							if (now - enemy.animTimer > ohjusFrameDuration) {
								enemy.animFrame = (enemy.animFrame + 1) % ohjusFrameCount;
								enemy.animTimer = now;
							}
						}
					} catch (error) {
						console.error("Error updating missile animation:", error);
						// Initialize animation values if missing
						enemy.animFrame = 0;
						enemy.animTimer = Date.now();
					}
				}
				// Handle regular and shooting enemies
				else if (!enemy.isCircular) {
					enemy.y += enemy.speed;
					
					// Make shooting enemies shoot
					if (enemy.isShooting) {
						enemyShoot(enemy);
					}
				}
				
				// Calculate actual hitbox size
				const playerHitboxSize = player.size * player.hitboxRatio;
				// Use hitbox center offset to keep hitbox centered within the sprite
				const playerHitboxOffset = (player.size - playerHitboxSize) / 2;
				
				// Check for collision with player's adjusted hitbox
				if (!playerInvulnerable && checkCollision(enemy, {
				    x: player.x - playerHitboxSize/2,
				    y: player.y - playerHitboxSize/2,
				    width: playerHitboxSize,
				    height: playerHitboxSize
				})) {
					// Calculate damage based on enemy type
					let damage = 10; // Default damage
					if (enemy.isSpinner && enemy.launched) {
						damage = 30; // Spinner deals 30 damage when launched
					} else if (enemy.isMissile) {
						damage = 15; // Missiles deal 15 damage
					}
					
					// Check if shield is active
					if (shieldActive) {
						// Shield absorbs the hit
						shieldActive = false;
						createExplosion(player.x, player.y, 0.8); // Shield break effect
					} else {
						// No shield, take damage normally
						player.hp -= damage;
					}
					
					// Add explosion at the collision point
					createExplosion(enemy.x, enemy.y);
					
					// Mark that this enemy was destroyed by collision, not by bullets
					// (so no powerup will spawn from this enemy)
					enemy.destroyedByCollision = true;
					
					enemies.splice(i, 1);
					if (circularGroup) {
						circularGroup.members = circularGroup.members.filter(m => m !== enemy);
					}
					if (player.hp <= 0) {
						endGame();
					}
					continue;
				}
				
				// Check if enemy is off-screen
				if ((!enemy.isCircular && !enemy.isMissile && !enemy.isSpinner && enemy.y > canvas.height + enemy.height) ||
					(enemy.isSpinner && enemy.launched && (enemy.x < -50 || enemy.x > canvas.width + 50 || enemy.y < -50 || enemy.y > canvas.height + 50))) {
					enemies.splice(i, 1);
					if (circularGroup) {
						circularGroup.members = circularGroup.members.filter(m => m !== enemy);
					}
				}
			}
		}

function drawEnemies() {
    enemies.forEach(enemy => {
        if (enemy.isSpinner) {
            // Save context for rotation
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            
            // Draw the spinner with the image
            const size = enemy.width * 2.2; // Adjust size as needed
            
            // Draw the spinning star image
            ctx.drawImage(window.spinnerEnemyImage, 
                -size/2, -size/2,
                size, size);
            
            // If not launched yet, add a pulsing effect
            if (!enemy.launched) {
                // Pulsing overlay while charging
                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.4;
                ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
                ctx.globalCompositeOperation = 'overlay';
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Restore context
            ctx.restore();
        }
        else if (enemy.isMissile) {
			try {
				if (enemy.isOhjus && window.ohjusImage && window.ohjusImage.complete) {
					// Draw animated ohjus
					ctx.save();
					ctx.translate(enemy.x, enemy.y);
					
					// Simplified: Just draw the frame without rotation
					const frameY = (enemy.animFrame || 0) * ohjusFrameHeight;
					
					ctx.drawImage(
						window.ohjusImage,
						0, frameY, 
						ohjusFrameWidth, ohjusFrameHeight,
						-enemy.width, -enemy.height,
						enemy.width * 2, enemy.height * 2
					);
					
					ctx.restore();
				} else {
					// Fallback for if the image isn't loaded
					ctx.fillStyle = '#FF3300';
					ctx.beginPath();
					ctx.arc(enemy.x, enemy.y, enemy.width/2, 0, Math.PI * 2);
					ctx.fill();
				}
			} catch (error) {
				console.error("Error drawing missile:", error);
				// Very simple fallback
				ctx.fillStyle = 'red';
				ctx.fillRect(enemy.x - 10, enemy.y - 10, 20, 20);
			}
		}
        else if (enemy.isCircular) {
            // Apply rotation for circular enemies
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            ctx.drawImage(window.circularEnemyImage,           
                -enemy.width,
                -enemy.height,
                enemy.width * 2,
                enemy.height * 2
            );
            ctx.restore();
        } 
        else if (enemy.isShooting) {
            // Apply rotation for shooting enemies
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            ctx.drawImage(window.shootingEnemyImage,
                -enemy.width,
                -enemy.height,
                enemy.width * 2,
                enemy.height * 2
            );
            ctx.restore();
        } 
        else {
            // Apply rotation for regular enemies
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            ctx.drawImage(window.enemyImage, 
                -enemy.width,
                -enemy.height,
                enemy.width * 2,
                enemy.height * 2
            );
            ctx.restore();
        }
    });
}

function drawBullets() {
    ctx.fillStyle = '#4CAF50'; // Always use green (#4CAF50) for player bullets
    player.bullets.forEach(bullet => {
        ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width * 1.5, bullet.height * 1.5);
    });
}

function drawEnemyBullets() {
    ctx.fillStyle = '#FF6B6B';
    enemyBullets.forEach(bullet => {
        ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
    });
}
// Replace your current update function with this corrected version:
function update() {
	// Access the global mouseX and mouseY variables 
	// (don't redeclare them locally)
    // Make sure we don't run the game loop while loading
    if (isLoading) {
        requestAnimationFrame(update);
        return;
    }

    // If the game is not running, we shouldn't be in this function
    if (!isGameRunning) {
        // Clear the canvas with black to ensure no remnants of loading screen
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
    }
    
    // Track game time
    const now = Date.now();
    const deltaTime = now - lastTimeCheck;
    lastTimeCheck = now;
    gameTime += deltaTime / 1000; // Convert to seconds
	
	// Force consistent performance
	if (now - lastPerformanceBoost > PERFORMANCE_BOOST_INTERVAL) {
		lastPerformanceBoost = now;
		
		// Force layout recalculation to prevent throttling
		canvas.getBoundingClientRect();
		
		// Force audio to play if it's paused
		if (backgroundMusic && backgroundMusic.paused && isGameRunning) {
			backgroundMusic.play().catch(e => {}); // Ignore errors
		}
		
		// Force high performance
		if (window.gameAudioContext && window.gameAudioContext.state === 'suspended') {
			window.gameAudioContext.resume().catch(e => {});
		}
	}
    
    // Stop spawning regular enemies at 185 seconds
	if (gameTime >= 185 && !regularEnemiesDisabled) {
		regularEnemiesDisabled = true;
		console.log("Regular enemies disabled at time: " + gameTime);
	}

	// Spawn boss at 190 seconds, without clearing existing enemies
	if (gameTime >= 190 && !bossSpawned) {
		// Spawn boss without clearing enemies
		spawnBoss();
		console.log("Boss spawned at time: " + gameTime);
	}

    // Update powerup position and check for collection
    updatePowerup();
    
    // Stop spawning regular enemies at 3:20 (200 seconds)
    if (gameTime >= 185) {
        regularEnemiesDisabled = true;
    }
    
    // Clear screen
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add UI elements - always visible regardless of screen size
	// UI Background - make it slightly taller for better visibility
	const statusBarHeight = Math.max(50, Math.min(canvas.height * 0.08, 70));
	ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; // Make background more opaque
	ctx.fillRect(0, 0, canvas.width, statusBarHeight);

	// Score display - positioned to the left
	ctx.fillStyle = '#4CAF50';
	const fontSize = Math.max(16, statusBarHeight * 0.4); // Adjust font size
	ctx.font = `bold ${fontSize}px Arial`;
	ctx.textAlign = 'left';
	ctx.fillText(`Score: ${score}`, 20, statusBarHeight * 0.65);

	// HP text and bar - positioned to the right
	ctx.fillStyle = '#FFFFFF';
	ctx.font = `bold ${Math.max(14, statusBarHeight * 0.3)}px Arial`;
	ctx.textAlign = 'right';

	// HP bar - positioned to the right
	const hpBarWidth = Math.min(canvas.width * 0.25, 120);
	const hpBarHeight = statusBarHeight * 0.4;
	const hpPercent = player.hp / player.maxHp;

	// HP Bar background
	ctx.fillStyle = '#333';
	ctx.fillRect(canvas.width - hpBarWidth - 15, statusBarHeight * 0.35, hpBarWidth, hpBarHeight);

	// HP Bar fill with color based on percentage
	ctx.fillStyle = hpPercent > 0.6 ? '#4CAF50' : hpPercent > 0.3 ? '#FFC107' : '#F44336';
	ctx.fillRect(canvas.width - hpBarWidth - 15, statusBarHeight * 0.35, hpBarWidth * hpPercent, hpBarHeight);

	// Optional: Add border to HP bar for better visibility
	ctx.strokeStyle = '#FFFFFF';
	ctx.lineWidth = 1;
	ctx.strokeRect(canvas.width - hpBarWidth - 15, statusBarHeight * 0.35, hpBarWidth, hpBarHeight);

    // UI separators
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fillRect(canvas.width / 3, 5, 1, 30);
    ctx.fillRect(canvas.width * 2 / 3, 5, 1, 30);
    
    // Update and draw background
    updateStars();
    
    // Update and draw boss if it exists
	if (boss) {
		updateBoss();
		drawBoss();
		
		if (boss.laserActive && checkLaserCollision()) {
			// Add screen shake
			const shakeIntensity = 5;
			const shakeX = (Math.random() - 0.5) * shakeIntensity;
			const shakeY = (Math.random() - 0.5) * shakeIntensity;
			ctx.translate(shakeX, shakeY);
			
			// Red damage overlay
			ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
			ctx.fillRect(-shakeX, -shakeY, canvas.width, canvas.height);
			
			// Reset translation
			ctx.translate(-shakeX, -shakeY);
			
			// Check if shield is active
			if (shieldActive) {
				// Shield absorbs the laser hit
				shieldActive = false;
				createExplosion(player.x, player.y, 0.8); // Shield break effect
			} else {
				// No shield, take damage normally
				player.hp -= boss.laserDamage;
				hpElement.textContent = player.hp;
			}
			
			// Continuous explosion effects while taking laser damage
			createExplosion(player.x + (Math.random() - 0.5) * 20, player.y + (Math.random() - 0.5) * 20, 0.3);
			
			// Check for player death
			if (player.hp <= 0) {
				endGame();
			}
		}
		
		if (boss.laserCooldown) {
			// Visual feedback for cooldown
			const cooldownProgress = (now - boss.laserCooldownTimer) / boss.laserCooldownDuration;
			
			// Steam/smoke effect
			if (Math.random() < 0.1) {
				// Create small explosions around boss to simulate cooling down
				const angle = Math.random() * Math.PI * 2;
				const distance = Math.random() * boss.width/2;
				createExplosion(
					boss.x + Math.cos(angle) * distance,
					boss.y + Math.sin(angle) * distance,
					0.2
				);
			}
		}
	}

    drawStars();
    
	// Player movement and control
	if (gameStartSequence && !playerReady) {
		// Smoothly bring player up from bottom of screen
		player.y -= 2; // Move player up
		player.x = canvas.width / 2; // Keep centered during intro
		
		// Calculate target position - keep player in bottom third of screen
		const targetY = canvas.height * 0.8; // 80% down the screen
		
		// Check if player reached target position
		if (player.y <= targetY) {
			player.y = targetY;
			// Don't end gameStartSequence here - let it end when playerReady becomes true
		}
	} else if (playerReady && gameStartSequence) {
		// End the intro sequence when player becomes ready
		gameStartSequence = false;
	} else if (playerReady && !gameStartSequence) {
	// Only apply controls after intro sequence is complete
	// Handle launch effect or normal controls
	if (player.launchEffect && player.launchEffect.controlsDisabled) {
		// Player is being launched - no control, animate to target position
		const elapsed = Date.now() - player.launchEffect.startTime;
		const progress = Math.min(elapsed / player.launchEffect.duration, 1);
		
		// Smooth easing for launch effect (ease-out)
		const easedProgress = 1 - Math.pow(1 - progress, 3);
		
		// Interpolate position during launch
		player.x = player.launchEffect.startX + (player.launchEffect.targetX - player.launchEffect.startX) * easedProgress;
		player.y = player.launchEffect.startY + (player.launchEffect.targetY - player.launchEffect.startY) * easedProgress;
		
		// End launch effect when complete
		if (progress >= 1) {
			player.launchEffect = null;
		}
	} else {
		// Normal touch/mouse follow controls
		if (typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined') {
			let targetX = mouseX;
			let targetY = mouseY;
			
			// Add offset for mobile to prevent finger blocking player
			if (isMobile) {
				targetY -= 40; // Move player 40 pixels above finger position
			}
			
			// Smoothly interpolate toward touch/mouse position (with mobile offset)
			player.x = player.x + (targetX - player.x) * 0.2;
			player.y = player.y + (targetY - player.y) * 0.2;
		}
	}
		
		// Always shoot when player is ready
		shoot();
		
		// Keep player within bounds
		player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
		player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));
	}
    // Check invulnerability timer
	if (playerInvulnerable) {
		const currentTime = Date.now();
		const elapsed = currentTime - playerInvulnerableTimer;
		
		if (gameStartSequence) {
			// Stay invulnerable during intro animation
		}
		else if (bossCollisionInvulnerability) {
			// Boss collision invulnerability (0.5 seconds)
			if (elapsed >= 500) {
				playerInvulnerable = false;
				bossCollisionInvulnerability = false;
			}
		}
		else if (playerReady) {
			// Initial game invulnerability (3 seconds after player is ready)
			if (elapsed >= 3000) {
				playerInvulnerable = false;
			}
		}
	}
    
    // Update game elements
    updateBullets();
    updateEnemyBullets();
    updateEnemies();
    
    // Draw game elements
    drawBullets();
    drawEnemyBullets();
    drawPowerup(); // Draw powerup if it exists
    drawEnemies();
    
    // Draw player with animation
    updatePlayerAnimation();
    if (window.playerImage.complete) {
        // Apply visual effect if player is invulnerable
        if (playerInvulnerable) {
            // Make player flash by changing opacity based on time
            ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 100) * 0.4; // Values between 0.0 and 0.8
        }
        
        // Draw player
        const sourceX = 0;
        const sourceY = playerAnimFrame * playerFrameHeight;
        
        ctx.drawImage(
            window.playerImage,
            sourceX, sourceY, playerFrameWidth, playerFrameHeight,
            player.x - player.size/2, player.y - player.size/2,
            player.size, player.size
        );
        
        // Reset global alpha
        if (playerInvulnerable) {
            ctx.globalAlpha = 1.0;
        }
    } else {
        // Fallback if image isn't loaded
        if (playerInvulnerable) {
            ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 100) * 0.4;
        }
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);
        if (playerInvulnerable) {
            ctx.globalAlpha = 1.0;
        }
    }
	// Draw shield if active - ADD THIS CODE AFTER THE PLAYER DRAWING CODE
	if (shieldActive) {
		ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3; // Pulsing shield effect
		ctx.fillStyle = '#00BFFF';
		ctx.beginPath();
		ctx.arc(player.x, player.y, player.size * 0.65, 0, Math.PI * 2);
		ctx.fill();
		
		// Add shield border
		ctx.globalAlpha = 0.8;
		ctx.strokeStyle = '#FFFFFF';
		ctx.lineWidth = 2;
		ctx.stroke();
		
		// Reset alpha
		ctx.globalAlpha = 1.0;
	}
    
    // Draw explosions
    updateAndDrawExplosions();
    
    // Update explosion animation
    if (explosionAnimation) {
        updateExplosion();
    }
	// Force high performance mode on mobile
	if (isMobile && navigator.scheduling && navigator.scheduling.isInputPending) {
		navigator.scheduling.isInputPending({includeContinuous: true});
	}
	// Force high performance mode on mobile
	if (isMobile && navigator.scheduling && navigator.scheduling.isInputPending) {
		navigator.scheduling.isInputPending({includeContinuous: true});
	}

	gameLoop = requestAnimationFrame(update);
}

function updatePlayerAnimation() {
    // Update animation frame based on timer
    const now = Date.now();
    if (now - playerAnimTimer > playerFrameDuration) {
        playerAnimFrame = (playerAnimFrame + 1) % playerFrameCount;
        playerAnimTimer = now;
    }
}
// Add this function outside of any other function
// Modify the drawMobileControls function
function drawMobileControls() {
    if (!isMobile || !playerReady) return;
    
    // Draw joystick base with improved visibility
    ctx.globalAlpha = 0.5; // Increased from 0.3 for better visibility
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.arc(joystick.baseX, joystick.baseY, joystick.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Add a visible border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw joystick knob
    ctx.globalAlpha = 0.7; // Increased from 0.5
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.arc(joystick.knobX, joystick.knobY, joystick.knobRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw fire button with improved visibility
    ctx.globalAlpha = fireButton.pressed ? 0.8 : 0.6; // Increased for better visibility
    ctx.fillStyle = '#FF4444';
    ctx.beginPath();
    ctx.arc(fireButton.x, fireButton.y, fireButton.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Add a visible border for fire button
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw fire icon in button
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.moveTo(fireButton.x - 15, fireButton.y);
    ctx.lineTo(fireButton.x + 15, fireButton.y);
    ctx.lineTo(fireButton.x, fireButton.y - 20);
    ctx.closePath();
    ctx.fill();
    
    ctx.globalAlpha = 1.0; // Reset alpha
}

// Add this function outside of any other function
function updatePlayerMovement() {
    if (gameStartSequence && !playerReady) {
        // Intro animation - same as before
        player.y = canvas.height + 100;
        player.x = canvas.width / 2;
        
        if (player.y <= canvas.height - 100) {
            player.y = canvas.height - 100;
        }
    } else if (playerReady) {
        if (isMobile) {
            // Mobile joystick controls
            if (joystick.active) {
                // Calculate direction vector
                const dx = joystick.knobX - joystick.baseX;
                const dy = joystick.knobY - joystick.baseY;
                
                // Normalize the vector and apply to player position
                const length = Math.sqrt(dx * dx + dy * dy);
                if (length > 0) {
                    const moveSpeed = 3; // Adjust as needed
                    player.x += (dx / length) * moveSpeed;
                    player.y += (dy / length) * moveSpeed;
                }
            }

        } else {
            // Desktop keyboard controls
            const moveSpeed = 0.4;
            
            if (keys['ArrowLeft']) player.x -= moveSpeed;
            if (keys['ArrowRight']) player.x += moveSpeed;
            if (keys['ArrowUp']) player.y -= moveSpeed;
            if (keys['ArrowDown']) player.y += moveSpeed;
            
        }
        
		// Automatic shooting when player is ready
		if (playerReady) {
			shoot();
		}
		
        // Keep player within bounds (for both control methods)
        player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
		player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));
    }
}
        // Event listeners
		canvas.addEventListener('mousemove', (e) => {
			const rect = canvas.getBoundingClientRect();
			mouseX = e.clientX - rect.left;
			mouseY = e.clientY - rect.top;
		});
        canvas.addEventListener('mousedown', () => {
            isMouseDown = true;
        });
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
		//iOS
		canvas.addEventListener('gesturestart', function(e) {
			e.preventDefault();
		});
		// Add touch support - simplified version
		canvas.addEventListener('touchstart', (e) => {
			e.preventDefault();
			
			if (!playerReady) return;
			
			const rect = canvas.getBoundingClientRect();
			const touch = e.touches[0]; // Get the first touch
			
			// Set mouseX and mouseY from touch position
			mouseX = (touch.clientX - rect.left) * (canvas.width / rect.width);
			mouseY = (touch.clientY - rect.top) * (canvas.height / rect.height);
		}, { passive: false });

		canvas.addEventListener('touchmove', (e) => {
			e.preventDefault();
			
			if (!playerReady) return;
			
			const rect = canvas.getBoundingClientRect();
			const touch = e.touches[0]; // Get the first touch
			
			// Update mouseX and mouseY from touch position
			mouseX = (touch.clientX - rect.left) * (canvas.width / rect.width);
			mouseY = (touch.clientY - rect.top) * (canvas.height / rect.height);
		}, { passive: false });

		// Can remove touchend handler or simplify it
		canvas.addEventListener('touchend', (e) => {
			// Optional - can leave empty or remove
		});


		canvas.addEventListener('touchmove', (e) => {
			e.preventDefault();
			
			if (!playerReady) return;
			
			const rect = canvas.getBoundingClientRect();
			
			for (let i = 0; i < e.touches.length; i++) {
				const touch = e.touches[i];
				const touchX = touch.clientX - rect.left;
				const touchY = touch.clientY - rect.top;
				
				// Normalize touchX and touchY to the canvas scale
				const normalizedX = touchX * (canvas.width / rect.width);
				const normalizedY = touchY * (canvas.height / rect.height);
				
				// Update joystick if it's active (regardless of screen position)
				if (joystick.active) {
					const joystickDistance = Math.sqrt(
						Math.pow(normalizedX - joystick.baseX, 2) + 
						Math.pow(normalizedY - joystick.baseY, 2)
					);
					
					if (joystickDistance <= joystick.maxDistance) {
						joystick.knobX = normalizedX;
						joystick.knobY = normalizedY;
					} else {
						// Limit the knob to the maximum distance
						const angle = Math.atan2(normalizedY - joystick.baseY, normalizedX - joystick.baseX);
						joystick.knobX = joystick.baseX + Math.cos(angle) * joystick.maxDistance;
						joystick.knobY = joystick.baseY + Math.sin(angle) * joystick.maxDistance;
					}
				}
			}
		}, { passive: false });

			// Update touchend handler to better track active touches
			canvas.addEventListener('touchend', (e) => {
				// Check remaining touches to see if any are still on our controls
				const rect = canvas.getBoundingClientRect();
				let joystickStillActive = false;
				
				// Loop through all ACTIVE touches to see if any are still on our controls
				for (let i = 0; i < e.touches.length; i++) {
					const touch = e.touches[i];
					const touchX = touch.clientX - rect.left;
					const touchY = touch.clientY - rect.top;
					
					// Normalize touchX and touchY to the canvas scale
					const normalizedX = touchX * (canvas.width / rect.width);
					const normalizedY = touchY * (canvas.height / rect.height);
					
					// Check if any touch is near the joystick
					const joystickDistance = Math.sqrt(
						Math.pow(normalizedX - joystick.baseX, 2) + 
						Math.pow(normalizedY - joystick.baseY, 2)
					);
					
					if (joystickDistance <= joystick.radius * 1.5) { // Use a slightly larger area for detection
						joystickStillActive = true;
					}
				}
				
				// Reset controls if no touches remain on them
				if (!joystickStillActive) {
					joystick.active = false;
					joystick.knobX = joystick.baseX;
					joystick.knobY = joystick.baseY;
				}
			});
        // Initial render

        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
if (document.readyState === "complete" || document.readyState === "interactive") {
    setTimeout(function() {
        console.log("Document already loaded, initializing manually");
        // Initialize images if they don't exist
        window.enemyImage = window.enemyImage || new Image();
        window.shootingEnemyImage = window.shootingEnemyImage || new Image();
        window.circularEnemyImage = window.circularEnemyImage || new Image();
        window.spinnerEnemyImage = window.spinnerEnemyImage || new Image();
        window.powerupImage = window.powerupImage || new Image();
        window.bossImage = window.bossImage || new Image();
        window.playerImage = window.playerImage || new Image();
        window.logoImage = window.logoImage || new Image();
        
        if (typeof startLoading === "function") {
            startLoading();
        } else {
            console.error("startLoading function not found");
        }
    }, 200);
}
    </script>
	<script>
        // Debug helper - fires when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM is now loaded - Elements check:");
            console.log("- Canvas:", document.getElementById('gameCanvas'));
            console.log("- Start Screen:", document.getElementById('startScreen'));
            console.log("- Start Button:", document.getElementById('startButton'));
            console.log("- Game Stats:", document.getElementById('gameStats'));
            console.log("- Game Over Screen:", document.getElementById('gameOverScreen'));
			console.log("Restart button canvas found:", !!document.getElementById('restartButtonCanvas'));
            
            // Add visible debug info
			/*
            setTimeout(function() {
                if (!isGameRunning) {
                    // Add emergency start button if game isn't running
                    var emergencyBtn = document.createElement('button');
                    emergencyBtn.textContent = "Emergency Start";
                    emergencyBtn.style = "position:fixed; top:10px; right:10px; z-index:9999; background:red; color:white; padding:10px;";
                    emergencyBtn.onclick = function() {
                        startGame();
                    };
                    document.body.appendChild(emergencyBtn);
                    
                    console.log("Added emergency start button");
                }
            }, 5000);
			*/
			const socialLinks = document.querySelectorAll('.socialLink');
    
			socialLinks.forEach(link => {
				link.addEventListener('touchstart', function() {
					this.style.transform = 'scale(1.1)';
				});
				
				link.addEventListener('touchend', function() {
					this.style.transform = 'scale(1)';
				});
			});

        });
		// Debug visualization function - call this at the end of your update function
		function drawDebugInfo() {
			if (!DEBUG_MODE) return;
			
			// Show FPS
			const now = Date.now();
			if (!window.lastFpsUpdate) window.lastFpsUpdate = now;
			if (!window.frameCount) window.frameCount = 0;
			if (!window.currentFps) window.currentFps = 0;
			
			window.frameCount++;
			
			if (now - window.lastFpsUpdate > 1000) {
				window.currentFps = window.frameCount;
				window.frameCount = 0;
				window.lastFpsUpdate = now;
			}
			
			// Draw debug info
			ctx.fillStyle = 'white';
			ctx.font = '12px Arial';
			ctx.textAlign = 'left';
			ctx.fillText(`FPS: ${window.currentFps}`, 10, canvas.height - 60);
			ctx.fillText(`Enemies: ${enemies.length}`, 10, canvas.height - 45);
			ctx.fillText(`Bullets: ${player.bullets.length + enemyBullets.length}`, 10, canvas.height - 30);
			ctx.fillText(`Game Time: ${Math.floor(gameTime)}s`, 10, canvas.height - 15);
		}
    </script>
</body>
</html>
