<!DOCTYPE html>
<html>
<head>
    <title>Tahtien Tappaja</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: black;
            font-family: Arial, sans-serif;
            
        }
        #gameCanvas {
            border: 2px solid #333;
        }
        .screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            color: white;
            text-align: center;
        }
        .button {
            background: #4CAF50;
            border: none;
            padding: 15px 30px;
            color: white;
            cursor: pointer;
            font-size: 18px;
        }
        #gameStats {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            display: none;
        }
        #gameOverScreen {
            display: none;
            z-index: 200;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="gameStats">
        <div>Score: <span id="score">0</span></div>
        <div>HP: <span id="hp">100</span></div>
    </div>
    <div id="startScreen" class="screen">
        <h1>TÃ¤htien Tappaja</h1>
        <button id="startButton" class="button">Uusi Peli</button>
    </div>
    <div id="gameOverScreen" class="screen">
        <h2>Game Over</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartButton" class="button">Restart Game</button>
    </div>
    <script>
	// Asset loading handler
function assetLoaded() {
    assetsLoaded++;
    console.log("Asset loaded. Total: " + assetsLoaded + "/" + totalAssets);
    
    // Update loading screen
    showLoadingScreen();
    
    // Show start screen when all assets are loaded
    if (assetsLoaded >= totalAssets) {
        console.log("All assets loaded, showing start screen");
        isLoading = false;
        setTimeout(() => {
            startScreen.style.display = 'block';
        }, 500); // Small delay to ensure loading screen can finish rendering
    }
}
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
		const startScreen = document.getElementById('startScreen');
		const gameOverScreen = document.getElementById('gameOverScreen');
		const gameStats = document.getElementById('gameStats');
		const startButton = document.getElementById('startButton');
		const restartButton = document.getElementById('restartButton');
		const scoreElement = document.getElementById('score');
		const hpElement = document.getElementById('hp');
		const finalScoreElement = document.getElementById('finalScore');
		





		
		canvas.width = 400;
        canvas.height = 800;
        // Game state global variables
		let assetsLoaded = 0;
		let totalAssets = 8; // enemyImage, shootingEnemyImage, circularEnemyImage, powerupImage, bossImage, playerImage, spinnerEnemyImage, backgroundMusic
		let isLoading = true;
		let backgroundMusic = null;
		let powerupActive = false;
		let powerupBulletsLeft = 0;
		let powerup = null;
		const powerupMilestones = [100, 500, 1000, 3000];
		let reachedMilestones = [false, false, false, false];
		let powerupSpawned = false;
        let gameLoop;
        let isGameRunning = false;
        let lastShot = 0;
        let score = 0;
        const shootingDelay = 250;
		let rapidFireShootingDelay = shootingDelay / 3; //200% faster
		let gameTime = 0; // Time in seconds
		let lastTimeCheck = 0;
		let explosionAnimation = null;
		let bossSpawned = false;
		let regularEnemiesDisabled = false;
		let boss = null;
		let lastBossMissile = 0;
		const bossMissileDelay = 5000; // 10 seconds
// Add this function to properly initialize loading
function startLoading() {
    // Hide start screen initially
    startScreen.style.display = 'none';
    
    // Show loading screen first
    showLoadingScreen();
    
    // Start loading assets
    loadAllAssets();
}

// Fix the loadAllAssets function to use window.enemyImage references:
function loadAllAssets() {
    // Set up all asset loading
    window.enemyImage.onload = assetLoaded;
    window.enemyImage.onerror = assetLoaded;
    window.shootingEnemyImage.onload = assetLoaded;
    window.shootingEnemyImage.onerror = assetLoaded;
    window.circularEnemyImage.onload = assetLoaded;
    window.circularEnemyImage.onerror = assetLoaded;
	window.spinnerEnemyImage.onload = assetLoaded;
	window.spinnerEnemyImage.onerror = assetLoaded;
    window.powerupImage.onload = assetLoaded;
    window.powerupImage.onerror = assetLoaded;
    window.bossImage.onload = assetLoaded;
    window.bossImage.onerror = assetLoaded;
    window.playerImage.onload = function() {
        // Draw the image on the start screen once it's loaded
        const startScreenImage = document.createElement('div');
        startScreenImage.style.margin = '20px auto';
        startScreenImage.innerHTML = `<img src="luke.png" width="400" height="400" alt="Player Ship">`;
        
        // Insert the image before the start button
        const startButton = document.getElementById('startButton');
        startScreen.insertBefore(startScreenImage, startButton);
        
        assetLoaded();
    };
    window.playerImage.onerror = assetLoaded;
    
    // Now set the sources to start loading
    window.enemyImage.src = 'punatahti.png';
    window.shootingEnemyImage.src = 'sinitahti.png';
    window.circularEnemyImage.src = 'vihertahti.png';
	window.spinnerEnemyImage.src = 'keltatahti.png';
    window.powerupImage.src = 'powerup1.png';
    window.bossImage.src = 'boss.png';
    window.playerImage.src = 'luke.png';
    
    // Setup audio preloading
    try {
        const tempAudio = new Audio();
        tempAudio.addEventListener('canplaythrough', assetLoaded, {once: true});
        tempAudio.addEventListener('error', assetLoaded, {once: true});
        tempAudio.src = 'tappaja.mp3';
    } catch (e) {
        console.error("Audio preload error:", e);
        assetLoaded(); // Count as loaded even if it fails
    }
}

// Add this at the end of your script block
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM loaded, initializing game...");
    // Initialize image objects first
    window.enemyImage = new Image();
    window.shootingEnemyImage = new Image();
    window.circularEnemyImage = new Image();
    window.spinnerEnemyImage = new Image();
    window.powerupImage = new Image();
    window.bossImage = new Image();
    window.playerImage = new Image();
    
    // Set initial display for screens
    gameStats.style.display = 'none';
    gameOverScreen.style.display = 'none';
    startScreen.style.display = 'none'; // Hide initially until loading
    
    // Add these lines to ensure the button listeners are properly attached
    startButton.addEventListener('click', function() {
        console.log("Start button clicked!");
        startGame();
    });
    restartButton.addEventListener('click', restartGame);
	
	// Start loading assets
	startLoading();
});


        let lastGroupSpawn = 0;
        const groupSpawnDelay = 15000; // Spawn group every 15 seconds
        // Player
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 80,
            size: 50,
            hp: 100,
            maxHp: 100,
            bullets: []
        };
        // Game objects
        const enemies = [];
        const enemyBullets = [];
        let circularGroup = null;
        // Background stars
        const stars = [];
        const NUM_STARS = 100;
        // Initialize stars with different sizes and speeds
        for (let i = 0; i < NUM_STARS; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5, // Stars of different sizes (0.5 to 2.5)
                speed: Math.random() * 0.3 + 0.1 // Very slow speeds (0.1 to 0.4)
            });
        }

function showLoadingScreen() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw loading text
    ctx.fillStyle = 'white';
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Loading...', canvas.width / 2, canvas.height / 2 - 50);
    
    // Draw loading bar background
    ctx.fillStyle = '#333';
    const barWidth = 200;
    const barHeight = 20;
    ctx.fillRect(canvas.width / 2 - barWidth / 2, canvas.height / 2, barWidth, barHeight);
    
    // Draw loading bar progress
    const progress = assetsLoaded / totalAssets;
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(canvas.width / 2 - barWidth / 2, canvas.height / 2, barWidth * progress, barHeight);
    
    // Draw percentage
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`${Math.round(progress * 100)}%`, canvas.width / 2, canvas.height / 2 + 40);
}

		// Create a function to initialize and play the music
function initializeMusic() {
    if (!backgroundMusic) {
        backgroundMusic = new Audio('');
		backgroundMusic.src = 'tappaja.mp3';
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.5; // Set volume to 50%
        
        // Use the play method
        try {
            const playPromise = backgroundMusic.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("Audio autoplay was prevented: ", error);
                    // Create a Play Music button
                    const musicButton = document.createElement('button');
                    musicButton.innerHTML = "Play Music";
                    musicButton.style.position = "absolute";
                    musicButton.style.top = "10px";
                    musicButton.style.right = "10px";
                    musicButton.style.zIndex = "1000";
                    musicButton.addEventListener('click', () => {
                        backgroundMusic.play();
                        musicButton.remove();
                    });
                    document.body.appendChild(musicButton);
                });
            }
        } catch (e) {
            console.log("Audio error: ", e);
        }
    } else if (backgroundMusic.paused) {
        try {
            backgroundMusic.play().catch(e => console.log("Could not resume audio: ", e));
        } catch (e) {
            console.log("Audio resume error: ", e);
        }
    }
}




        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }
        function drawStars() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        // Mouse state
        let mouseX = 0;
		let mouseY = 0;
        let isMouseDown = false;
        function startGame() {
		    console.log("Starting game...");
				// Start the background music
			initializeMusic();
			startScreen.style.display = 'none';
			isGameRunning = true;
			score = 0;
			gameTime = 0;
            isGameRunning = true;
            score = 0;
			gameTime = 0;
			lastTimeCheck = Date.now();
			bossSpawned = false;
			regularEnemiesDisabled = false;
			boss = null;
			explosionAnimation = null;
            player.hp = player.maxHp;
            player.bullets = [];
            enemies.length = 0;
            enemyBullets.length = 0;
            circularGroup = null;
            lastGroupSpawn = Date.now();
						// Add these lines to both the startGame and restartGame functions
			powerupActive = false;
			powerupBulletsLeft = 0;
			powerup = null;
			powerupSpawned = false;
			reachedMilestones = [false, false, false, false];

			// Remove any existing powerup indicator
			const indicator = document.getElementById('powerupIndicator');
			if (indicator) {
				indicator.remove();
			}
            
            scoreElement.textContent = score;
            hpElement.textContent = player.hp;
            
            gameLoop = requestAnimationFrame(update);
			gameStats.style.display = 'block'; //
        }
        function restartGame() {
            isGameRunning = true;
            score = 0;
			gameTime = 0;
			lastTimeCheck = Date.now();
			bossSpawned = false;
			regularEnemiesDisabled = false;
			boss = null;
			explosionAnimation = null; // Make sure this is here
			
            player.hp = player.maxHp;
            player.bullets = [];
            enemies.length = 0;
            enemyBullets.length = 0;
            circularGroup = null;
            lastGroupSpawn = Date.now();
									// Add these lines to both the startGame and restartGame functions
			powerupActive = false;
			powerupBulletsLeft = 0;
			powerup = null;
			powerupSpawned = false;
			reachedMilestones = [false, false, false, false];

			// Remove any existing powerup indicator
			const indicator = document.getElementById('powerupIndicator');
			if (indicator) {
				indicator.remove();
			}

            
            scoreElement.textContent = score;
            hpElement.textContent = player.hp;
            
            gameOverScreen.style.display = 'none';
            gameStats.style.display = 'block';
            gameLoop = requestAnimationFrame(update);
        }
		// Add this function to spawn the boss
		function spawnBoss() {
			bossSpawned = true;
			regularEnemiesDisabled = true;
			lastBossMissile = Date.now();
			boss = {
				x: canvas.width / 2,
				y: 100,
				width: 75,
				height: 75,
				hp: 220,
				maxHp: 200,
				lastShot: 0,
				shootingDelay: 1000, // 1 second
				moveDirection: 1,    // 1 for right, -1 for left
				moveSpeed: 1.5,
				movePattern: 0,      // 0 for horizontal, 1 for diagonal
				patternTimer: 0,     // For switching patterns
				patternDuration: 5000 // Switch pattern every 5 seconds
			};
		}

		// Add this function to handle boss shooting
		function bossShooting() {
			if (!boss) return;
			
			const now = Date.now();
			
			// Regular shots
			if (now - boss.lastShot >= boss.shootingDelay) {
				// Three bullets in a spread pattern
				for (let i = -1; i <= 1; i++) {
					enemyBullets.push({
						x: boss.x + (i * 20),
						y: boss.y + boss.height / 2,
						width: 5,
						height: 10,
						speed: 3 + Math.random(),
						angle: Math.PI/2 + (i * Math.PI/12) // Spread pattern
					});
				}
				boss.lastShot = now;
			}
			
			// Missile shots
			if (now - lastBossMissile >= bossMissileDelay) {
				// Create a missile enemy that follows the player
				const missile = {
					x: boss.x,
					y: boss.y + boss.height / 2,
					width: 20,
					height: 30,
					hp: 6,
					speed: 0.7,
					isMissile: true,
					points: 20
				};
				enemies.push(missile);
				lastBossMissile = now;
			}
		}

		// Add this function to update boss movement
		function updateBoss() {
			if (!boss) return;
			
			const now = Date.now();
			
			// Check if it's time to switch patterns
			if (now - boss.patternTimer >= boss.patternDuration) {
				boss.movePattern = (boss.movePattern + 1) % 3; // Toggle between 3 patterns
				boss.patternTimer = now;
			}
			
			// Pattern 0: Horizontal movement
			if (boss.movePattern === 0) {
				boss.x += boss.moveSpeed * boss.moveDirection;
				
				// Bounce at edges
				if (boss.x > canvas.width - boss.width/2 || boss.x < boss.width/2) {
					boss.moveDirection *= -1;
				}
			}
			// Pattern 1: Diagonal movement
			else if (boss.movePattern === 1) {
				boss.x += boss.moveSpeed * boss.moveDirection;
				boss.y += Math.sin(now / 500) * 2; // Wavy up-down movement
				
				// Bounce at edges
				if (boss.x > canvas.width - boss.width/2 || boss.x < boss.width/2) {
					boss.moveDirection *= -1;
				}
				
				// Keep within vertical bounds
				boss.y = Math.max(50, Math.min(canvas.height / 3, boss.y));
			}
			// Pattern 2: "Charge" at player
			else if (boss.movePattern === 2) {
				const targetX = player.x;
				const dx = targetX - boss.x;
				boss.x += (dx * 0.02); // Move 2% of the way to player each frame
				
				// Slow up/down movement during this pattern
				boss.y = 80 + Math.sin(now / 1000) * 30;
			}
			
			// Boss shooting
			bossShooting();
			
			// Check for player collision with boss
			if (checkCollision({
				x: boss.x - boss.width/2,
				y: boss.y - boss.height/2,
				width: boss.width,
				height: boss.height
			}, {
				x: player.x - player.size/2,
				y: player.y - player.size/2,
				width: player.size,
				height: player.size
			})) {
				player.hp -= 20;
				if (player.hp <= 0) {
					endGame();
				}
			}
		}

		// Add this function to draw the boss
		function drawBoss() {
			if (!boss) return;
			
			// Draw boss image or a placeholder if image isn't loaded
			if (window.bossImage.complete) {
				ctx.drawImage(window.bossImage, 
					boss.x - boss.width/2, 
					boss.y - boss.height/2,
					boss.width,
					boss.height
				);
			} else {
				// Placeholder: Evil red face
				ctx.fillStyle = '#ff0000';
				ctx.beginPath();
				ctx.arc(boss.x, boss.y, boss.width/2, 0, Math.PI * 2);
				ctx.fill();
				
				// Evil eyes
				ctx.fillStyle = 'black';
				ctx.beginPath();
				ctx.arc(boss.x - 15, boss.y - 10, 8, 0, Math.PI * 2);
				ctx.arc(boss.x + 15, boss.y - 10, 8, 0, Math.PI * 2);
				ctx.fill();
				
				// Evil mouth
				ctx.beginPath();
				ctx.arc(boss.x, boss.y + 10, 20, 0, Math.PI);
				ctx.stroke();
			}
			
			// Draw boss HP bar
			const hpBarWidth = boss.width * 1.5;
			const hpBarHeight = 8;
			const hpPercentage = boss.hp / boss.maxHp;
			
			// HP Bar background
			ctx.fillStyle = '#333';
			ctx.fillRect(boss.x - hpBarWidth/2, boss.y - boss.height/2 - 15, hpBarWidth, hpBarHeight);
			
			// HP Bar fill
			ctx.fillStyle = `rgb(${255 * (1 - hpPercentage)}, ${255 * hpPercentage}, 0)`;
			ctx.fillRect(boss.x - hpBarWidth/2, boss.y - boss.height/2 - 15, hpBarWidth * hpPercentage, hpBarHeight);
		}
        function endGame() {
            isGameRunning = false;
            cancelAnimationFrame(gameLoop);
            finalScoreElement.textContent = score;
            gameStats.style.display = 'none';
            gameOverScreen.style.display = 'block';
        }
        function spawnCircularGroup() {
            const groupCenterX = canvas.width / 2;
            const groupCenterY = -120;
            const radius = 120;
            
            circularGroup = {
                centerX: groupCenterX,
                centerY: groupCenterY,
                radius: radius,
                angle: 0,
                rotationSpeed: 0.005,
                moveSpeed: 0.3,
                members: []
            };
            // Spawn 10 enemies in a circle
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                const enemy = {
                    baseAngle: angle,
                    x: groupCenterX + Math.cos(angle) * radius,
                    y: groupCenterY + Math.sin(angle) * radius,
                    width: 20,
                    height: 20,
                    hp: 2,
                    points: 15,
                    isCircular: true
                };
                circularGroup.members.push(enemy);
                enemies.push(enemy);
            }
        }
        function updateCircularGroup() {
            if (!circularGroup) return;
            // Update group position
            circularGroup.centerY += circularGroup.moveSpeed;
            circularGroup.angle += circularGroup.rotationSpeed;
            // Update each member's position
            circularGroup.members.forEach((enemy, index) => {
                const angle = enemy.baseAngle + circularGroup.angle;
                enemy.x = circularGroup.centerX + Math.cos(angle) * circularGroup.radius;
                enemy.y = circularGroup.centerY + Math.sin(angle) * circularGroup.radius;
            });
            // Remove group if it's off screen
            if (circularGroup.centerY > canvas.height + circularGroup.radius * 2) {
                circularGroup.members.forEach(member => {
                    const index = enemies.indexOf(member);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                });
                circularGroup = null;
            }
            // Or if all members are destroyed
            else if (circularGroup.members.every(m => !enemies.includes(m))) {
                circularGroup = null;
            }
        }
        function spawnEnemy() {
            // Check if it's time to spawn a circular group
            const now = Date.now();
            if (!circularGroup && now - lastGroupSpawn >= groupSpawnDelay) {
                spawnCircularGroup();
                lastGroupSpawn = now;
                return;
            }
            // Regular enemy spawn logic
            const isShootingEnemy = Math.random() < 0.3;
            const enemy = {
                x: Math.random() * (canvas.width - 20),
                y: -20,
                width: 20,
                height: 20,
                speed: isShootingEnemy ? 0.8 : 1.1,
                hp: isShootingEnemy ? 3 : 2,
                points: isShootingEnemy ? 20 : 10,
                isShooting: isShootingEnemy,
                lastShot: 0,
                shootingDelay: 2000
            };
            enemies.push(enemy);
        }
		// Add this function to spawn the powerup
function spawnPowerup() {
    powerup = {
        x: Math.random() * (canvas.width - 30) + 15, // Keep away from edges
        y: -20,
        width: 30,
        height: 30,
        speed: 0.8
    };
    powerupSpawned = true;
}

// Add this function to update the powerup position and check for collision
function updatePowerup() {
    if (!powerup) return;
    
    powerup.y += powerup.speed;
    
    // Check if player collected the powerup
    if (checkCollision(powerup, {
        x: player.x - player.size/2,
        y: player.y - player.size/2,
        width: player.size,
        height: player.size
    })) {
        powerupActive = true;
        powerupBulletsLeft = 300;
        powerup = null;
        
    }
    
    // Remove if offscreen
    if (powerup && powerup.y > canvas.height) {
        powerup = null;
    }
}

	// Add this function to draw the powerup
function drawPowerup() {
    if (!powerup) return;
    
    ctx.drawImage(window.powerupImage, 
        powerup.x - powerup.width/2, 
        powerup.y - powerup.height/2,
        powerup.width,
        powerup.height
    );
}

	// Modify the shoot function to handle rapid fire
	function shoot() {
		const now = Date.now();
		const currentShootingDelay = powerupActive ? rapidFireShootingDelay : shootingDelay;
		
		if (now - lastShot >= currentShootingDelay) {
			player.bullets.push({
				x: player.x,
				y: player.y,
				width: 3,
				height: 8,
				speed: 7
			});
			lastShot = now;
			
			// Track powerup bullets
			if (powerupActive) {
				powerupBulletsLeft--;
				
				
				// End powerup if bullets are used up
				if (powerupBulletsLeft <= 0) {
					powerupActive = false;
					
				}
			}
		}
	}

        function enemyShoot(enemy) {
            const now = Date.now();
            if (now - enemy.lastShot >= enemy.shootingDelay) {
                enemyBullets.push({
                    x: enemy.x + enemy.width / 2,
                    y: enemy.y + enemy.height,
                    width: 3,
                    height: 8,
                    speed: 2.5
                });
                enemy.lastShot = now;
            }
        }
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
function updateBullets() {
    for (let i = player.bullets.length - 1; i >= 0; i--) {
        const bullet = player.bullets[i];
        bullet.y -= bullet.speed;
        
        if (bullet.y < 0) {
            player.bullets.splice(i, 1);
            continue;
        }
        
        // Check for boss hit
        if (boss && checkCollision(bullet, {
            x: boss.x - boss.width/2,
            y: boss.y - boss.height/2,
            width: boss.width,
            height: boss.height
        })) {
            boss.hp--;
            player.bullets.splice(i, 1);
            
            // Boss death
            if (boss.hp <= 0) {
                // Start explosion animation instead of instant damage
                explosionAnimation = {
                    centerX: boss.x,
                    centerY: boss.y,
                    radius: 10,
                    startTime: Date.now(),
                    duration: 5000, // 5 seconds
                    completed: false
                };
                
                boss = null;
                score += 1000; // Big points for defeating boss
                continue;
            }
            continue;
        }
        
        // Regular enemy hit check
        for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            if (checkCollision(bullet, enemy)) {
                enemy.hp--;
                player.bullets.splice(i, 1);
                
                if (enemy.hp <= 0) {
                    score += enemy.points;
                    scoreElement.textContent = score;
                    enemies.splice(j, 1);
                    if (circularGroup) {
                        circularGroup.members = circularGroup.members.filter(m => m !== enemy);
                    }
                }
                break;
            }
        }
    }
}
function updateEnemyBullets() {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        bullet.y += bullet.speed;
        
        if (bullet.y > canvas.height) {
            enemyBullets.splice(i, 1);
            continue;
        }
        
        // Check player collision with bullet
        if (checkCollision(bullet, {
            x: player.x - player.size/2,
            y: player.y - player.size/2,
            width: player.size,
            height: player.size
        })) {
            player.hp -= 5; // Bullet damage
            hpElement.textContent = player.hp;
            enemyBullets.splice(i, 1);
            
            if (player.hp <= 0) {
                endGame();
            }
        }
    }
}
 
		function updateExplosion() {
    if (!explosionAnimation) return;
    
    const now = Date.now();
    const elapsed = now - explosionAnimation.startTime;
    const progress = Math.min(elapsed / explosionAnimation.duration, 1);
	
	// If animation is complete, don't render anything else
    if (progress >= 1) {
        if (!explosionAnimation.completed) {
            explosionAnimation.completed = true;
            
            // Defeat player when animation completes
            player.hp -= 100;
            hpElement.textContent = player.hp;
            if (player.hp <= 0) {
                endGame();
            }
        }
        // Don't continue with rendering if animation is done
        return;
    }
    
    // Calculate expanding radius - make it larger to ensure it covers the whole screen
    const maxRadius = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) * 1.5;
    explosionAnimation.radius = progress * maxRadius;
    
    // Create a brighter, more intense explosion
    // Start with pure white, then add a yellow/orange glow at the end
    const brightness = 1 - (progress * 0.3); // Stays brighter longer
    
    // Create a pulsing effect for added intensity
    const pulse = Math.sin(progress * 10) * 0.1 * (1 - progress) + 1;
	
    // Draw the explosion in a layer above everything else
    // First draw a bright white center that covers the entire screen
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness * pulse})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height); // Cover the entire screen	
    
    // Then draw the expanding circle with a glow
    const gradient = ctx.createRadialGradient(
        explosionAnimation.centerX, explosionAnimation.centerY, 0,
        explosionAnimation.centerX, explosionAnimation.centerY, explosionAnimation.radius
    );
    
    gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness * 0.9})`);
    gradient.addColorStop(0.6, `rgba(255, 255, 200, ${brightness * 0.7})`);
    gradient.addColorStop(0.8, `rgba(255, 170, 100, ${brightness * 0.5})`);
    gradient.addColorStop(1, `rgba(255, 100, 50, ${brightness * 0.3})`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(explosionAnimation.centerX, explosionAnimation.centerY, 
            explosionAnimation.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Add visual feedback - random smaller "sparkles" for dramatic effect
    if (progress < 0.8) {
        for (let i = 0; i < 5; i++) {
            const sparkX = explosionAnimation.centerX + (Math.random() - 0.5) * explosionAnimation.radius * progress;
            const sparkY = explosionAnimation.centerY + (Math.random() - 0.5) * explosionAnimation.radius * progress;
            const sparkSize = 20 + Math.random() * 50;
            
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Check if animation is complete
    if (elapsed >= explosionAnimation.duration && !explosionAnimation.completed) {
        explosionAnimation.completed = true;
        
        // Defeat player when animation completes
        player.hp -= 100;
        if (player.hp <= 0) {
            endGame();
        }
    }
}
        function updateEnemies() {
			// Only spawn regular enemies if boss isn't active and not disabled
			if (!regularEnemiesDisabled && enemies.length < 5 && Math.random() < 0.02) {
				// Check if game time is past 1 minute (60 seconds) and add chance for spinner
				if (gameTime >= 60 && Math.random() < 0.2) { // 20% chance to spawn spinner instead of regular enemy
					// Spawn spinner enemy
					const spinnerEnemy = {
						x: Math.random() * (canvas.width - 30) + 15,
						y: 30, // Slightly below the top
						width: 25,
						height: 25,
						hp: 12, // Tougher than regular enemies
						speed: 6, // Fast when launched
						points: 50, // Worth more points
						isSpinner: true,
						spinTimer: Date.now(),
						spinDuration: 3000, // 3 seconds of spinning
						angle: 0, // Current rotation angle
						launched: false
					};
					enemies.push(spinnerEnemy);
				} else {
					spawnEnemy();
				}
			}
			
			updateCircularGroup();
			
			for (let i = enemies.length - 1; i >= 0; i--) {
				const enemy = enemies[i];
				
				if (enemy.isSpinner) {
					// Increase rotation angle
					enemy.angle += 0.1; // Rotation speed
					
					// Check if it's time to launch
					const now = Date.now();
					if (!enemy.launched && now - enemy.spinTimer >= enemy.spinDuration) {
						enemy.launched = true;
						
						// Calculate direction to player
						const dx = player.x - enemy.x;
						const dy = player.y - enemy.y;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						// Store normalized direction
						if (distance > 0) {
							enemy.dirX = dx / distance;
							enemy.dirY = dy / distance;
						} else {
							enemy.dirX = 0;
							enemy.dirY = 1; // Default downward
						}
					}
					
					// Move if launched
					if (enemy.launched) {
						enemy.x += enemy.dirX * enemy.speed;
						enemy.y += enemy.dirY * enemy.speed;
					}
				}
				else if (enemy.isMissile) {
					// Calculate direction to player for homing
					const dx = player.x - enemy.x;
					const dy = player.y - enemy.y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					
					// Update position
					if (distance > 0) {
						enemy.x += (dx / distance) * enemy.speed;
						enemy.y += (dy / distance) * enemy.speed;
					} else {
						enemy.y += enemy.speed;
					}
				}
				// Handle regular and shooting enemies
				else if (!enemy.isCircular) {
					enemy.y += enemy.speed;
					
					// Make shooting enemies shoot
					if (enemy.isShooting) {
						enemyShoot(enemy);
					}
				}
				
				// Check for collision with player for all enemy types
				if (checkCollision(enemy, {
					x: player.x - player.size/2,
					y: player.y - player.size/2,
					width: player.size,
					height: player.size
				})) {
					// Different damage based on enemy type
					if (enemy.isSpinner && enemy.launched) {
						player.hp -= 30; // Spinner deals 30 damage when launched
					} else if (enemy.isMissile) {
						player.hp -= 15; // Missiles deal 15 damage
					} else {
						player.hp -= 10; // Regular enemies deal 10 damage
					}
					
					enemies.splice(i, 1);
					if (circularGroup) {
						circularGroup.members = circularGroup.members.filter(m => m !== enemy);
					}
					if (player.hp <= 0) {
						endGame();
					}
					continue;
				}
				
				// Check if enemy is off-screen
				if ((!enemy.isCircular && !enemy.isMissile && !enemy.isSpinner && enemy.y > canvas.height + enemy.height) ||
					(enemy.isSpinner && enemy.launched && (enemy.x < -50 || enemy.x > canvas.width + 50 || enemy.y < -50 || enemy.y > canvas.height + 50))) {
					enemies.splice(i, 1);
					if (circularGroup) {
						circularGroup.members = circularGroup.members.filter(m => m !== enemy);
					}
				}
			}
		}

function drawEnemies() {
    enemies.forEach(enemy => {
        if (enemy.isSpinner) {
            // Save context for rotation
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            
            // Draw the spinner with the image
            const size = enemy.width * 2; // Adjust size as needed
            
            // Draw the spinning star image
            ctx.drawImage(window.spinnerEnemyImage, 
                -size/2, -size/2,
                size, size);
            
            // If not launched yet, add a pulsing effect
            if (!enemy.launched) {
                // Pulsing overlay while charging
                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.4;
                ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
                ctx.globalCompositeOperation = 'overlay';
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Restore context
            ctx.restore();
        }
        else if (enemy.isMissile) {
            // Draw missile...
			ctx.fillStyle = '#FF3300';
            ctx.beginPath();
            // Missile body
            ctx.moveTo(enemy.x, enemy.y - enemy.height/2);
            ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
            ctx.lineTo(enemy.x - enemy.width/2, enemy.y + enemy.height/2);
            ctx.closePath();
            ctx.fill();
            
            // Fire trail
            ctx.fillStyle = 'orange';
            ctx.beginPath();
            ctx.moveTo(enemy.x - enemy.width/4, enemy.y + enemy.height/2);
            ctx.lineTo(enemy.x, enemy.y + enemy.height);
            ctx.lineTo(enemy.x + enemy.width/4, enemy.y + enemy.height/2);
            ctx.closePath();
            ctx.fill();
        } 
        else if (enemy.isCircular) {
            ctx.drawImage(window.circularEnemyImage,           
                enemy.x - enemy.width/2,
                enemy.y - enemy.height/2,
                enemy.width * 2,
                enemy.height * 2
            );
        } 
        else if (enemy.isShooting) {
            ctx.drawImage(window.shootingEnemyImage,
                enemy.x - enemy.width/2,
                enemy.y - enemy.height/2,
                enemy.width * 2,
                enemy.height * 2
            );
        } 
        else {
            ctx.drawImage(window.enemyImage, 
                enemy.x - enemy.width/2, 
                enemy.y - enemy.height/2,
                enemy.width * 2,
                enemy.height * 2
            );
        }
    });
}

function drawBullets() {
    ctx.fillStyle = '#FFF';
    player.bullets.forEach(bullet => {
        ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
    });
}

function drawEnemyBullets() {
    ctx.fillStyle = '#FF6B6B';
    enemyBullets.forEach(bullet => {
        ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
    });
}
        function update() {
			if (isLoading) {
				showLoadingScreen();
				requestAnimationFrame(update);
				return;
			}
    
			if (!isGameRunning) return;
			// Track game time
			const now = Date.now();
			const deltaTime = now - lastTimeCheck;
			lastTimeCheck = now;
			gameTime += deltaTime / 1000; // Convert to seconds
			// Check for boss spawn at 3:30 (210 seconds)
			if (gameTime >= 189 && !bossSpawned) {
				spawnBoss();
			}
			for (let i = 0; i < powerupMilestones.length; i++) {
    if (score >= powerupMilestones[i] && !reachedMilestones[i] && !powerup && !powerupActive) {
        spawnPowerup();
        reachedMilestones[i] = true;
        break; // Only spawn one powerup at a time
    }
}

// Update powerup position and check for collection
updatePowerup();
			// Stop spawning regular enemies at 3:20 (200 seconds)
			if (gameTime >= 200) {
				regularEnemiesDisabled = true;
			}
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
			// Add enhanced UI elements
			ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
			ctx.fillRect(0, 0, canvas.width, 40); // Top bar for stats

			// Make score more prominent
			ctx.fillStyle = '#4CAF50';
			ctx.font = 'bold 18px Arial';
			ctx.textAlign = 'left';
			ctx.fillText(`Score: ${score}`, 10, 25);
			
			// Display Powerup status if active
			if (powerupActive) {
				ctx.fillStyle = 'yellow';
				ctx.font = 'bold 18px Arial';
				ctx.textAlign = 'center';
				ctx.fillText(`Rapid Fire: ${powerupBulletsLeft}`, canvas.width / 2, 25);
			}

			// Display HP as a bar
			const hpBarWidth = 120;
			const hpBarHeight = 15;
			const hpPercent = player.hp / player.maxHp;

			// HP Bar background
			ctx.fillStyle = '#333';
			ctx.fillRect(canvas.width - hpBarWidth - 10, 15, hpBarWidth, hpBarHeight);

			// HP Bar fill with color based on percentage
			ctx.fillStyle = hpPercent > 0.6 ? '#4CAF50' : hpPercent > 0.3 ? '#FFC107' : '#F44336';
			ctx.fillRect(canvas.width - hpBarWidth - 10, 15, hpBarWidth * hpPercent, hpBarHeight);

			// Add separators
			ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
			ctx.fillRect(canvas.width / 3, 5, 1, 30);
			ctx.fillRect(canvas.width * 2 / 3, 5, 1, 30);
            // Update and draw background first
            updateStars();
			// Update and draw boss if it exists
if (boss) {
    updateBoss();
    drawBoss();
}

            drawStars();
            player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, mouseX));
			// Add movement bounds for Y axis - keep player in bottom 2/3 of screen
			player.y = Math.max(canvas.height/3, Math.min(canvas.height - player.size/2, mouseY));
            if (isMouseDown) {
                shoot();
            }
            updateBullets();
            updateEnemyBullets();
            updateEnemies();
            drawBullets();
            drawEnemyBullets();
			// Draw powerup if it exists
			drawPowerup();
            drawEnemies();
            ctx.drawImage(window.playerImage, 
				player.x - player.size/2, 
				player.y - player.size/2,
				player.size,
				player.size
			);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(mouseX - 10, player.y);
            ctx.lineTo(mouseX + 10, player.y);
            ctx.moveTo(mouseX, player.y - 10);
            ctx.lineTo(mouseX, player.y + 10);
            ctx.stroke();
			
			// Update explosion animation
			if (explosionAnimation) {
				updateExplosion();
			}
            gameLoop = requestAnimationFrame(update);
        }
        // Event listeners
		canvas.addEventListener('mousemove', (e) => {
			const rect = canvas.getBoundingClientRect();
			mouseX = e.clientX - rect.left;
			mouseY = e.clientY - rect.top;
		});
        canvas.addEventListener('mousedown', () => {
            isMouseDown = true;
        });
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
		// Add touch support
		canvas.addEventListener('touchmove', (e) => {
			e.preventDefault();
			const rect = canvas.getBoundingClientRect();
			const touch = e.touches[0];
			mouseX = touch.clientX - rect.left;
			mouseY = touch.clientY - rect.top;
			isMouseDown = true;  // Auto-shoot when touching
		});

		canvas.addEventListener('touchend', () => {
			isMouseDown = false;
		});

		canvas.addEventListener('touchstart', (e) => {
			e.preventDefault();
			const rect = canvas.getBoundingClientRect();
			const touch = e.touches[0];
			mouseX = touch.clientX - rect.left;
			mouseY = touch.clientY - rect.top;
			isMouseDown = true;
		});
        // Initial render

        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

    </script>
</body>
</html>